use crate::shared_unit_data::*;
use crate::distillation_shortcut_unit::DistillationShortcutUnit;
use cobia::*;

/// The IntegerParameter class implements a CAPE-OPEN 1.2 integer parameter.
///
/// Parameters must implement the ICapeIdentification and ICapeParameter interfaces.
/// In addition, integer parameters must implement the ICapeIntegerParameter interface.
///
/// This implementation can be used for both input and output parameters.
/// Input parameters can be set by the user, while output parameters are set by the unit operation.
///
/// Although CAPE-OPEN defines a value for an integer that is not specified (the equivalent of NaN
/// for real values), this value is not widely supported, and unspecified values are not allowed
/// in this implementation.
///
/// Any invalid values (outside the bounds of the parameter) will raise an error when set.
/// Therefore, any parameter is valid.

#[cape_object_implementation(
		interfaces = {
			cape_open_1_2::ICapeIdentification,
			cape_open_1_2::ICapeParameter,
			cape_open_1_2::ICapeIntegerParameter,
		},
		new_arguments = {
			name,
			description,
			is_input,
			shared_unit_data,
			default_value,
			minimum_value,
			maximum_value,
		}
  )] 
pub struct IntegerParameter {
	/// The name of the parameter
	pub(crate) name: CapeStringImpl,
	/// The description of the parameter
	description: CapeStringImpl,
	/// Indicates whether this parameter is an input (true) or an output (false)
	is_input : bool,
	/// Shared data for the unit, containing unit-specific information
	shared_unit_data: SharedUnitDataRef, 
	/// The current value of the parameter
	pub(crate) value : i32,
	/// Default value of the parameter
	default_value : i32,
	/// Minimum value of the parameter
	minimum_value : i32,
	/// Maximum value of the parameter
	maximum_value : i32,
}

impl IntegerParameter {

	fn new(
		name: CapeStringImpl,
		description: CapeStringImpl,
		is_input: bool,
		shared_unit_data: SharedUnitDataRef,
		default_value: i32,
		minimum_value: i32,
		maximum_value: i32,
	) -> Self {
		Self {
			name,
			description,
			is_input,
			shared_unit_data,
			value: default_value,
			default_value,
			minimum_value,
			maximum_value,
			cobia_object_data:std::default::Default::default(), //field generated by the cape_object_implementation macro; can be set to default
		}
	}

}

impl std::fmt::Display for IntegerParameter {

	/// Format the IntegerParameter as a string for display purposes.
	///
	/// The std::fmt::Display interface is used when generating the 
	/// source name of the object that raises an error.
	///
	/// # Arguments:
	/// * `f` - A mutable reference to a `std::fmt::Formatter` where the formatted string will be written.
	///
	/// # Returns:
	/// * A `std::fmt::Result` indicating the success or failure of the formatting operation.

	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f,"Parameter '{}' of {} unit '{}'",self.name, DistillationShortcutUnit::NAME, self.shared_unit_data.borrow().name)
    }

}

impl cape_open_1_2::ICapeIdentification for IntegerParameter {

	/// Get the name of the component.
	///
	/// # Arguments:
	/// * `name` - A mutable reference to a `CapeStringOut` where the name will be set.
	///
	/// # Returns:
	/// * A `Result` indicating success or failure. If successful, the name is set in `name`.

	fn get_component_name(&mut self,name:&mut CapeStringOut) -> Result<(), COBIAError> {
		name.set(&self.name)?;
		Ok(())
	}

	/// Get the description of the component.
	///
	/// # Arguments:
	/// * `description` - A mutable reference to a `CapeStringOut` where the description will be set.
	///
	/// # Returns:
	/// * A `Result` indicating success or failure. If successful, the description is set in `description`.

	fn get_component_description(&mut self,description:&mut CapeStringOut) -> Result<(), COBIAError> {
		description.set(&self.description)?;
		Ok(())
	}

	/// Set the name of the component.
	///
	/// This method is not allowed for this parameter implementation and will return an error.

	fn set_component_name(&mut self, _name: &CapeStringIn) -> Result<(), COBIAError> {
		Err(cobia::COBIAError::Code(cobia::COBIAERR_DENIED))
	}

	/// Set the description of the component.
	///
	/// This method is not allowed for this parameter implementation and will return an error.

	fn set_component_description(&mut self, _desc: &CapeStringIn) -> Result<(), COBIAError> {
		Err(cobia::COBIAError::Code(cobia::COBIAERR_DENIED))
	}
}

impl cape_open_1_2::ICapeParameter for IntegerParameter {

	/// Get the validation status of the parameter.
	///
	/// As this parameter does not accept any values that are not valid, 
	/// the parameter is always valid.
	/// 
	/// # Returns:
	/// * A `Result` containing the validation status, which is always `CapeValid` for this implementation.

    fn get_val_status(&mut self) -> Result<cape_open_1_2::CapeValidationStatus,COBIAError> {
		Ok(cape_open_1_2::CapeValidationStatus::CapeValid)
    }

	/// Get the mode of the parameter.
	///
	/// # Returns:
	/// * A `Result` containing the mode of the parameter, which is either `CapeInput` or `CapeOutput` based on the `is_input` field.

    fn get_mode(&mut self) -> Result<cape_open_1_2::CapeParamMode,COBIAError> {
        if self.is_input {
			Ok(cape_open_1_2::CapeParamMode::CapeInput)
		} else {
			Ok(cape_open_1_2::CapeParamMode::CapeOutput)
		}
    }

	/// Get the type of the parameter.
	///
	/// # Returns:
	/// * A `Result` containing the type of the parameter, which is always `CapeParameterInteger` for this implementation.

    fn get_type(&mut self) -> Result<cape_open_1_2::CapeParamType,COBIAError> {
        Ok(cape_open_1_2::CapeParamType::CapeParameterInteger)
    }

	/// Validate the parameter.
	///
	/// As this parameter does not accept any values that are not valid, 
	/// the parameter is always valid.
	/// 
	/// # Arguments:
	/// * `message` - A mutable reference to a `CapeStringOut` where any validation error messages will be set.
	///
	/// # Returns:
	/// * A `Result` containing a `CapeBoolean` indicating whether the parameter is valid or not.

    fn validate(&mut self,_message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError> {
		Ok(true as CapeBoolean)
    }

	/// Reset the parameter to its default value.
	///
	/// This method sets the value of the parameter back to its default value and marks the unit as dirty.
	/// It also resets the validation status to `CapeNotValidated`.
	///
	/// # Returns:
	/// * A `Result` indicating success or failure. If successful, the value is reset to the default value.

    fn reset(&mut self) -> Result<(),COBIAError> {
		if self.value!=self.default_value {
			self.value = self.default_value; 
			let mut shared=self.shared_unit_data.borrow_mut();
			shared.dirty=true;
			shared.validation_status=cape_open_1_2::CapeValidationStatus::CapeNotValidated;
		}
		Ok(())
	}
}

impl cape_open_1_2::ICapeIntegerParameter for IntegerParameter {

	/// Get the value of the parameter.
	///
	/// This method retrieves the current value of the parameter.
	///
	/// # Returns:
	/// * A `Result` containing the current value of the parameter as `CapeInteger`.

    fn get_value(&mut self) -> Result<CapeInteger,COBIAError> {
        Ok(self.value)
    }

	/// Set the value of the parameter.
	///
	/// This implementation accepts a blank value for the parameters, but 
	/// it does not allow an invalid value to be set.
	///
	/// Only input parameters can be set.
	///
	/// If the value is set, it marks the unit as dirty and not validated.
	///
	/// # Arguments:
	/// * `value` - The value to set for the parameter, which should be a `CapeInteger`.
	///
	/// # Returns:
	/// * A `Result` indicating success or failure.

    fn set_value(&mut self,value:CapeInteger) -> Result<(),COBIAError> {
        if !self.is_input {
			return Err(COBIAError::Code(COBIAERR_DENIED));
		}
		if value < self.minimum_value {
			return Err(COBIAError::Message(format!("Value of {} below minimum value of {}",value,self.minimum_value)));
		}
		if value > self.maximum_value {
			return Err(COBIAError::Message(format!("Value of {} above maximum value of {}",value,self.maximum_value)));
		}
		if self.value != value {
			self.value = value;
			let mut shared=self.shared_unit_data.borrow_mut();
			shared.dirty=true;
			shared.validation_status=cape_open_1_2::CapeValidationStatus::CapeNotValidated;
		}
		Ok(())
    }

	/// Get the default value of the parameter.
	///
	/// This method retrieves the default value of the parameter.
	///
	/// # Returns:
	/// * A `Result` containing the default value of the parameter as `CapeInteger`, or an error.

    fn get_default_value(&mut self) -> Result<CapeInteger,COBIAError> {
		Ok(self.default_value)
    }

	/// Get the lower bound of the parameter.
	///
	/// This method retrieves the lower bound of the parameter.
	///
	/// # Returns:
	/// * A `Result` containing the lower bound of the parameter as `CapeInteger`, or an error.

    fn get_lower_bound(&mut self) -> Result<CapeInteger,COBIAError> {
		Ok(self.default_value)
    }

	/// Get the upper bound of the parameter.
	///
	/// This method retrieves the upper bound of the parameter.
	///
	/// # Returns:
	/// * A `Result` containing the upper bound of the parameter as `CapeInteger`, or an error.

    fn get_upper_bound(&mut self) -> Result<CapeInteger,COBIAError> {
       Ok(self.maximum_value)
    }

	/// Validate whether a given value is valid for this parameter.
	///
	/// This method checks if the provided value is within the bounds of the parameter and meets the dimensionality requirements.
	///
	/// Output parameters are not validated, as they are set by the unit operation and not by the user.
	///
	/// # Arguments:
	/// * `value` - The value to validate, which should be a `CapeInteger`.
	/// * `message` - A mutable reference to a `CapeStringOut` where any validation error messages will be set.
	///
	/// # Returns:
	/// * A `Result` containing a `CapeBoolean` indicating whether the value is valid or not. If the value is not valid, it sets an error message in `message`.

    fn validate(&mut self,value:CapeInteger,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError> {
        if !self.is_input {
			return Err(COBIAError::Code(COBIAERR_DENIED));
		}
		if value < self.minimum_value {
			message.set_string(format!("Value of {} below minimum value of {}",value,self.minimum_value))?;
			Ok(false as CapeBoolean)
		} else if value > self.maximum_value {
			message.set_string(format!("Value of {} above maximum value of {}",value,self.maximum_value))?;
			Ok(false as CapeBoolean)
		} else {
			Ok(true as CapeBoolean)
		}
    }
}

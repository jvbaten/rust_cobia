use crate::shared_unit_data::*;
use crate::material_port::MaterialPort;
use crate::distillation_shortcut_unit::DistillationShortcutUnit;
use cobia::*;

/// The PortCollection class implements a CAPE-OPEN 1.2 collection of unit ports for the DistillationShortcutUnit.
///
/// It provides methods to manage and access the ports associated with the unit.

#[cape_object_implementation(
		interfaces={ 
			cape_open_1_2::ICapeIdentification,
			cape_open_1_2::ICapeCollection<cape_open_1_2::CapeUnitPort>,
		},
		new_arguments={
			shared_unit_data
		}
  )] 
pub(crate) struct PortCollection {
	/// The name of the port collection
	name: CapeStringImpl,
	/// The description of the port collection
	description: CapeStringImpl,
	/// The ports contained in this collection
	ports : Vec<cape_open_1_2::CapeUnitPort>,
	/// Shared data for the unit, allowing access to common properties.
	shared_unit_data: SharedUnitDataRef, 
}

impl PortCollection {

	/// Creates a new `PortCollection` for the distillation shortcut unit.
	///
	/// # Arguments
	/// * `shared_unit_data` - A reference to shared data for the unit, which contains common properties.
	///
	/// # Returns
	/// A new instance of `PortCollection` initialized with the provided shared data.

	fn new(shared_unit_data: SharedUnitDataRef) -> Self {
		Self {
			name : CapeStringImpl::from(format!("{} port collection",DistillationShortcutUnit::NAME)),
			description : CapeStringImpl::from(format!("Port collection of {}",DistillationShortcutUnit::NAME)),
			ports: Vec::new(),
			shared_unit_data,
			cobia_object_data : std::default::Default::default(), //this member is generated by cape_object_implementation and can be set to default()
		}
	}

	/// Adds a port to the collection.
	///
	/// # Arguments
	/// * `port` - The port to be added to the collection.

	pub(crate) fn add_port(&mut self,port:cape_open_1_2::CapeUnitPort) {
		self.ports.push(port);
	}

	/// Obtain an iterator to iterate over the ports in the collection.
	///
	/// # Returns
	/// An iterator that yields references to the ports in the collection.

	pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut cape_open_1_2::CapeUnitPort> {
		self.ports.iter_mut()
	}

}

impl std::fmt::Display for PortCollection {

	/// Formats the port collection for display.
	///
	/// The std::fmt::Display interface is used when generating the 
	/// source name of the object that raises an error.
	///
	/// # Arguments
	/// * `f` - A mutable reference to the formatter where the output will be written.
	///
	/// # Returns
	/// A result indicating whether the formatting was successful or not.

	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f,"Port collection of {} unit '{}'",DistillationShortcutUnit::NAME, self.shared_unit_data.borrow().name)
    }

}

impl cape_open_1_2::ICapeIdentification for PortCollection {

	/// Get the name of the component.
	///
	/// # Arguments
	/// * `name` - A mutable reference to a `CapeStringOut` where the name will be set.
	///
	/// # Returns
	/// * A `Result` indicating success or failure. If successful, the name is set in `name`.

	fn get_component_name(&mut self,name:&mut CapeStringOut) -> Result<(), COBIAError> {
		name.set(&self.name)?;
		Ok(())
	}

	/// Get the description of the component.
	///
	/// # Arguments
	/// * `description` - A mutable reference to a `CapeStringOut` where the description will be set.
	///
	/// # Returns
	/// * A `Result` indicating success or failure. If successful, the description is set in `description`.

	fn get_component_description(&mut self,description:&mut CapeStringOut) -> Result<(), COBIAError> {
		description.set(&self.description)?;
		Ok(())
	}

	/// Set the name of the component.
	///
	/// # Arguments
	/// * `name` - A reference to a `CapeStringIn` containing the new name to be set.
	///
	/// # Returns
	/// * A `Result` indicating success or failure. This method is not allowed for this port implementation and will return an error.

	fn set_component_name(&mut self, _name: &CapeStringIn) -> Result<(), COBIAError> {
		Err(cobia::COBIAError::Code(cobia::COBIAERR_DENIED))
	}

	/// Set the description of the component.
	///
	/// # Arguments
	/// * `desc` - A reference to a `CapeStringIn` containing the new description to be set.
	///
	/// # Returns
	/// * A `Result` indicating success or failure. This method is not allowed for this port implementation and will return an error.

	fn set_component_description(&mut self, _desc: &CapeStringIn) -> Result<(), COBIAError> {
		Err(cobia::COBIAError::Code(cobia::COBIAERR_DENIED))
	}
}

impl cape_open_1_2::ICapeCollection<cape_open_1_2::CapeUnitPort> for PortCollection {

	/// Retrieves a port by its index.
	///
	/// # Arguments
	/// * `index` - The index of the port to retrieve.
	///
	/// # Returns
	/// * A `Result` containing the port if found, or an error if the index is out of bounds.

    fn item_by_index(&mut self,index:CapeInteger) -> Result<cape_open_1_2::CapeUnitPort,COBIAError> {
		if index<0 || index>=self.ports.len() as CapeInteger {
			Err(cobia::COBIAError::Code(cobia::COBIAERR_NOSUCHITEM))
		} else {
			Ok(self.ports[index as usize].clone())
		}
	}

	/// Retrieves a port by its name.
	///
	/// # Arguments
	/// * `name` - A reference to a `CapeStringIn` containing the name of the port to retrieve.
	///
	/// # Returns
	/// * A `Result` containing the port if found, or an error if no such item exists.

    fn item_by_name(&mut self,name:&CapeStringIn) -> Result<cape_open_1_2::CapeUnitPort,COBIAError> {
		//in a generic implementation we could obtain the item names from the ports via ICapeIdentification, 
		// but this involves copying the string. In this particular implementation, there is only one port
		// class to we cast the object to its class and use the name directly
		//alternatively, for a more performant implementation if the collection is expected to contain more
		// than a few items, we could obtain the names while adding the ports to the collection, and build
		// a hashmap of names to ports or port indices; see 'ParameterCollection' for an example of this.
		for port in self.ports.iter() {
			//unsafe because we must guarantee that the implementing object is MaterialPort:
			//  (it is, as this is the only object in the collection)
			let material_port=unsafe { MaterialPort::borrow(port) }; 
			if material_port.get_name().eq_ignore_case(name) {
				return Ok(port.clone());
			}
		}
		Err(cobia::COBIAError::Code(cobia::COBIAERR_NOSUCHITEM))
    }

	/// Retrieves the number of ports in the collection.
	///
	/// # Returns
	/// * A `Result` containing the number of ports as a `CapeInteger`.

    fn get_count(&mut self) -> Result<CapeInteger,COBIAError> {
        Ok(self.ports.len() as CapeInteger)
    }
}

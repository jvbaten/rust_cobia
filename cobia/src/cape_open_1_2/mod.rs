// This file was generated by cidl2rs
use crate::*;
use crate::cape_smart_pointer::CapeSmartPointer;
use std::marker::PhantomData;
use std::fmt;

//library ID
pub const LIBRARY_ID:CapeUUID=CapeUUID::from_slice(&[0x8du8,0x1du8,0x72u8,0x4fu8,0xabu8,0x15u8,0x48u8,0xe5u8,0x80u8,0xe4u8,0xa6u8,0x12u8,0x46u8,0x8eu8,0x68u8,0xd4u8]);

//Category IDs
pub const CATEGORYID_COMPONENT_1_2:CapeUUID=CapeUUID::from_slice(&[0x37u8,0xe0u8,0x30u8,0x33u8,0x63u8,0xb9u8,0x4fu8,0x55u8,0xb5u8,0xc4u8,0x80u8,0x7bu8,0xedu8,0xe0u8,0x3du8,0xebu8]);

//Interface IDs
pub const ICAPEIDENTIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x12u8,0xebu8,0xf1u8,0x84u8,0xf4u8,0x7au8,0x44u8,0x07u8,0xb5u8,0x2au8,0x7fu8,0xccu8,0x0au8,0x70u8,0x45u8,0x1cu8]);
pub const ICAPECOLLECTION_UUID:CapeUUID=CapeUUID::from_slice(&[0xb1u8,0x35u8,0xa4u8,0x43u8,0x2eu8,0xd8u8,0x45u8,0xefu8,0xbbu8,0x2du8,0xe6u8,0x8du8,0x2eu8,0x63u8,0x1cu8,0x31u8]);
pub const ICAPEPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0xdbu8,0xa6u8,0x93u8,0x1fu8,0x39u8,0x0cu8,0x42u8,0x29u8,0x9bu8,0x36u8,0xd6u8,0x59u8,0x79u8,0xdbu8,0xd0u8,0xc0u8]);
pub const ICAPEREALPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0xd2u8,0x75u8,0xb8u8,0x5eu8,0x94u8,0xe4u8,0x4cu8,0xa2u8,0x84u8,0xdeu8,0xd0u8,0x7fu8,0x72u8,0x9fu8,0x55u8,0x8au8]);
pub const ICAPEINTEGERPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0xa9u8,0x7au8,0xc0u8,0x97u8,0x0fu8,0xd0u8,0x42u8,0x26u8,0x99u8,0xbau8,0xd1u8,0xc9u8,0xaeu8,0x41u8,0xbdu8,0xddu8]);
pub const ICAPESTRINGPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0xf2u8,0x6cu8,0xe5u8,0x27u8,0x32u8,0x77u8,0x44u8,0x24u8,0xa6u8,0x29u8,0x7fu8,0x93u8,0x08u8,0xdbu8,0xa7u8,0xd3u8]);
pub const ICAPEBOOLEANPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0x33u8,0xbeu8,0xf4u8,0x2du8,0x73u8,0x48u8,0x41u8,0x41u8,0xb6u8,0xd7u8,0xe2u8,0xefu8,0xb3u8,0x71u8,0x46u8,0x67u8]);
pub const ICAPEARRAYPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0xaeu8,0xebu8,0x1du8,0x66u8,0x82u8,0x27u8,0x48u8,0xbdu8,0x9au8,0x05u8,0x31u8,0x50u8,0xd0u8,0xdfu8,0x4eu8,0x5du8]);
pub const ICAPEARRAYREALPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0x96u8,0x18u8,0x66u8,0xf0u8,0xb1u8,0x96u8,0x45u8,0x54u8,0xb9u8,0x50u8,0x55u8,0x99u8,0xadu8,0xe2u8,0x60u8,0xd5u8]);
pub const ICAPEARRAYINTEGERPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0x22u8,0x10u8,0x3au8,0x3bu8,0xfbu8,0x08u8,0x43u8,0xd1u8,0x83u8,0xebu8,0x56u8,0x98u8,0x2au8,0x2eu8,0xa8u8,0xbau8]);
pub const ICAPEARRAYSTRINGPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0x03u8,0x77u8,0x51u8,0xf9u8,0x37u8,0xe7u8,0x4fu8,0x61u8,0xb7u8,0x0au8,0x5bu8,0xf5u8,0x75u8,0x1cu8,0xc3u8,0x4au8]);
pub const ICAPEARRAYBOOLEANPARAMETER_UUID:CapeUUID=CapeUUID::from_slice(&[0xbbu8,0x6bu8,0xf3u8,0x34u8,0xf5u8,0xb4u8,0x4eu8,0x08u8,0x9fu8,0xebu8,0x13u8,0x5du8,0xe8u8,0x21u8,0xb9u8,0x2fu8]);
pub const ICAPEPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x72u8,0xe7u8,0xe2u8,0xaeu8,0x9fu8,0x00u8,0x40u8,0xbau8,0x86u8,0x12u8,0xbfu8,0xf2u8,0x33u8,0x08u8,0x5eu8,0xfdu8]);
pub const ICAPEREALPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0xf0u8,0x56u8,0x53u8,0x3cu8,0x9fu8,0x56u8,0x44u8,0x87u8,0x8fu8,0xc9u8,0x00u8,0x47u8,0xa5u8,0x7au8,0xebu8,0x53u8]);
pub const ICAPEINTEGERPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x72u8,0x05u8,0x95u8,0x85u8,0x38u8,0x58u8,0x43u8,0xcau8,0x99u8,0x32u8,0xe3u8,0xa8u8,0xa8u8,0xc8u8,0x07u8,0x48u8]);
pub const ICAPESTRINGPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x7du8,0xa3u8,0x53u8,0x0au8,0x82u8,0x43u8,0x41u8,0x60u8,0x82u8,0x55u8,0xdfu8,0xb8u8,0x9au8,0x0au8,0xdau8,0x2au8]);
pub const ICAPEBOOLEANPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x03u8,0x60u8,0x43u8,0xd9u8,0x61u8,0x8fu8,0x45u8,0xd3u8,0xa6u8,0x4fu8,0x45u8,0x68u8,0x67u8,0x52u8,0x6au8,0xb7u8]);
pub const ICAPEARRAYPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x10u8,0x06u8,0x51u8,0x70u8,0x0cu8,0xb9u8,0x49u8,0x97u8,0x9fu8,0x19u8,0x38u8,0x95u8,0x7eu8,0x01u8,0x84u8,0xd6u8]);
pub const ICAPEARRAYREALPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0xf1u8,0x27u8,0xf8u8,0x98u8,0xa7u8,0xc3u8,0x41u8,0xa1u8,0xa7u8,0xf5u8,0x58u8,0xcbu8,0x35u8,0x99u8,0x5bu8,0x44u8]);
pub const ICAPEARRAYINTEGERPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x7bu8,0x51u8,0xd2u8,0xb9u8,0x14u8,0xadu8,0x4fu8,0xa8u8,0xb2u8,0x6eu8,0x8fu8,0x63u8,0x27u8,0x76u8,0xc8u8,0x02u8]);
pub const ICAPEARRAYSTRINGPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x43u8,0xafu8,0x3bu8,0xa8u8,0x22u8,0x06u8,0x4au8,0xb0u8,0xb4u8,0x64u8,0x51u8,0x3fu8,0x01u8,0x66u8,0x3au8,0x12u8]);
pub const ICAPEARRAYBOOLEANPARAMETERSPECIFICATION_UUID:CapeUUID=CapeUUID::from_slice(&[0x38u8,0x79u8,0x2cu8,0xa7u8,0x35u8,0x45u8,0x4au8,0x1bu8,0x9eu8,0x87u8,0xcdu8,0x85u8,0x56u8,0x12u8,0x7du8,0xe9u8]);
pub const ICAPEUTILITIES_UUID:CapeUUID=CapeUUID::from_slice(&[0x27u8,0x5cu8,0xb0u8,0x83u8,0x4fu8,0x4fu8,0x41u8,0xa8u8,0xbau8,0x08u8,0x52u8,0x11u8,0xb8u8,0xd4u8,0x8au8,0xe8u8]);
pub const ICAPESIMULATIONCONTEXT_UUID:CapeUUID=CapeUUID::from_slice(&[0x48u8,0xb2u8,0x11u8,0xc4u8,0xa1u8,0x58u8,0x46u8,0xc2u8,0x89u8,0x82u8,0xf8u8,0xbbu8,0xa6u8,0x44u8,0x10u8,0xbau8]);
pub const ICAPEDIAGNOSTIC_UUID:CapeUUID=CapeUUID::from_slice(&[0xd3u8,0x03u8,0x58u8,0x46u8,0xbeu8,0xaau8,0x4du8,0xacu8,0xafu8,0x98u8,0x74u8,0xf0u8,0x9au8,0xa1u8,0x7fu8,0x35u8]);
pub const ICAPEMATERIALMANAGER_UUID:CapeUUID=CapeUUID::from_slice(&[0xb7u8,0x5au8,0x64u8,0x37u8,0x07u8,0xfeu8,0x4eu8,0xf0u8,0xa1u8,0x67u8,0xefu8,0xcau8,0x0bu8,0xe5u8,0x2cu8,0xd8u8]);
pub const ICAPECOSEUTILITIES_UUID:CapeUUID=CapeUUID::from_slice(&[0x73u8,0x45u8,0x3eu8,0x94u8,0x64u8,0x18u8,0x4fu8,0x6au8,0xabu8,0x31u8,0xd2u8,0x8au8,0x69u8,0x16u8,0x95u8,0x53u8]);
pub const ICAPETHERMOMATERIAL_UUID:CapeUUID=CapeUUID::from_slice(&[0xf7u8,0xe3u8,0x51u8,0x7au8,0x49u8,0x22u8,0x4du8,0x55u8,0xa2u8,0x14u8,0xbbu8,0x53u8,0x75u8,0x5eu8,0x7du8,0x01u8]);
pub const ICAPETHERMOMATERIALCONTEXT_UUID:CapeUUID=CapeUUID::from_slice(&[0x6du8,0xaau8,0xc2u8,0x36u8,0x88u8,0x5cu8,0x47u8,0x0au8,0x82u8,0x86u8,0x36u8,0x80u8,0x5bu8,0xedu8,0x43u8,0x61u8]);
pub const ICAPETHERMOCOMPOUNDS_UUID:CapeUUID=CapeUUID::from_slice(&[0x30u8,0x9du8,0xc5u8,0x15u8,0xaeu8,0x97u8,0x4fu8,0xbeu8,0x8au8,0xa1u8,0xa0u8,0x8eu8,0x13u8,0x59u8,0xffu8,0x69u8]);
pub const ICAPETHERMOPHASES_UUID:CapeUUID=CapeUUID::from_slice(&[0xd8u8,0x09u8,0x01u8,0xa2u8,0x59u8,0xa2u8,0x43u8,0xb4u8,0x80u8,0x94u8,0xfeu8,0xacu8,0x64u8,0xf3u8,0xc7u8,0xe0u8]);
pub const ICAPETHERMOPROPERTYROUTINE_UUID:CapeUUID=CapeUUID::from_slice(&[0x82u8,0xf6u8,0xa4u8,0x58u8,0x2cu8,0xd7u8,0x4du8,0x5du8,0x8du8,0x6fu8,0xb8u8,0x02u8,0x78u8,0xdau8,0x3eu8,0xdbu8]);
pub const ICAPETHERMOEQUILIBRIUMROUTINE_UUID:CapeUUID=CapeUUID::from_slice(&[0x33u8,0x54u8,0x3fu8,0x96u8,0x97u8,0x08u8,0x4eu8,0xf3u8,0x92u8,0x27u8,0x3fu8,0x8du8,0x37u8,0x5fu8,0x6eu8,0xb5u8]);
pub const ICAPETHERMOUNIVERSALCONSTANT_UUID:CapeUUID=CapeUUID::from_slice(&[0xbeu8,0x14u8,0x7du8,0xcfu8,0x11u8,0xe0u8,0x4eu8,0xdeu8,0x96u8,0x4au8,0xa4u8,0x3fu8,0xa5u8,0x53u8,0xa9u8,0x90u8]);
pub const ICAPETHERMOPROPERTYPACKAGEMANAGER_UUID:CapeUUID=CapeUUID::from_slice(&[0xa3u8,0xa9u8,0x4fu8,0x1eu8,0x32u8,0xf1u8,0x47u8,0xe3u8,0xb0u8,0x19u8,0x57u8,0x18u8,0xfau8,0x56u8,0x07u8,0x57u8]);
pub const ICAPEUNIT_UUID:CapeUUID=CapeUUID::from_slice(&[0xafu8,0x5cu8,0x2cu8,0x3fu8,0x57u8,0xe1u8,0x47u8,0x85u8,0x83u8,0x7fu8,0x7au8,0x93u8,0xdbu8,0xcdu8,0x03u8,0xfbu8]);
pub const ICAPEUNITPORT_UUID:CapeUUID=CapeUUID::from_slice(&[0xa6u8,0x0du8,0x7au8,0x23u8,0x50u8,0x4du8,0x4au8,0xdau8,0xb6u8,0xcbu8,0x09u8,0xd6u8,0xd9u8,0x4du8,0x31u8,0x9eu8]);
pub const ICAPEPERSISTWRITER_UUID:CapeUUID=CapeUUID::from_slice(&[0xa8u8,0xc7u8,0x92u8,0x8au8,0xe2u8,0x88u8,0x4eu8,0x83u8,0xadu8,0xbdu8,0x0au8,0xbbu8,0x39u8,0x4au8,0xe5u8,0xa6u8]);
pub const ICAPEPERSISTREADER_UUID:CapeUUID=CapeUUID::from_slice(&[0x82u8,0x74u8,0x18u8,0xa6u8,0x65u8,0x15u8,0x40u8,0xcfu8,0x81u8,0xa7u8,0xdau8,0xb8u8,0xcfu8,0x8fu8,0xa1u8,0x76u8]);
pub const ICAPEPERSIST_UUID:CapeUUID=CapeUUID::from_slice(&[0xabu8,0xa6u8,0x5du8,0xc8u8,0x93u8,0xf9u8,0x49u8,0x53u8,0x89u8,0x7du8,0xa8u8,0xfau8,0x8eu8,0xa4u8,0xeeu8,0xaeu8]);
pub const ICAPEREPORT_UUID:CapeUUID=CapeUUID::from_slice(&[0x99u8,0xd2u8,0x06u8,0x68u8,0xcau8,0x44u8,0x42u8,0x37u8,0x8bu8,0x13u8,0x8du8,0x51u8,0x35u8,0xf4u8,0xd1u8,0x65u8]);
pub const ICAPEFLOWSHEETMONITORINGCOMPONENT_UUID:CapeUUID=CapeUUID::from_slice(&[0x35u8,0xb5u8,0x78u8,0x15u8,0xfcu8,0x6du8,0x4cu8,0x03u8,0xabu8,0xbbu8,0xe2u8,0xf5u8,0xdau8,0x76u8,0x77u8,0xb0u8]);
pub const ICAPESTREAM_UUID:CapeUUID=CapeUUID::from_slice(&[0xacu8,0x5fu8,0x88u8,0x16u8,0xbdu8,0x51u8,0x4bu8,0x3du8,0xb7u8,0xa4u8,0x05u8,0xffu8,0xddu8,0xdeu8,0xf1u8,0xc3u8]);
pub const ICAPEFLOWSHEETMONITORINGEVENTSINK_UUID:CapeUUID=CapeUUID::from_slice(&[0xebu8,0x4eu8,0x3bu8,0x42u8,0x77u8,0xfeu8,0x41u8,0xc5u8,0x81u8,0x48u8,0x47u8,0x60u8,0x82u8,0xccu8,0x02u8,0x53u8]);
pub const ICAPEFLOWSHEETMONITORING_UUID:CapeUUID=CapeUUID::from_slice(&[0x6bu8,0x1cu8,0xf4u8,0xa3u8,0xa3u8,0xe3u8,0x4eu8,0x96u8,0x9au8,0x10u8,0x73u8,0x75u8,0x00u8,0x63u8,0x72u8,0xf5u8]);
pub const ICAPETHERMOMATERIALCUSTOMDATA_UUID:CapeUUID=CapeUUID::from_slice(&[0x82u8,0xb7u8,0xdau8,0xbcu8,0x66u8,0xd2u8,0x4fu8,0xefu8,0x9au8,0x21u8,0x95u8,0xa7u8,0x44u8,0x00u8,0xb2u8,0xb2u8]);
pub const ICAPECUSTOMDATASOURCE_UUID:CapeUUID=CapeUUID::from_slice(&[0x97u8,0xc8u8,0x0au8,0xb8u8,0x95u8,0xd7u8,0x46u8,0xd8u8,0x90u8,0x29u8,0x5cu8,0x16u8,0x72u8,0xd2u8,0x36u8,0xc9u8]);
pub const ICAPETHERMOPETROLEUMFRACTIONS_UUID:CapeUUID=CapeUUID::from_slice(&[0x1eu8,0xbau8,0xd1u8,0x72u8,0x2bu8,0xe9u8,0x4au8,0x9eu8,0x95u8,0x49u8,0x03u8,0x07u8,0xe0u8,0x90u8,0xb0u8,0x28u8]);

//Enumerations

///CapeParamType
///
///CapeParamType enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeParamType {
	CapeParameterReal = 0,
	CapeParameterInteger = 1,
	CapeParameterString = 2,
	CapeParameterBoolean = 3,
	CapeParameterArrayReal = 4,
	CapeParameterArrayInteger = 5,
	CapeParameterArrayString = 6,
	CapeParameterArrayBoolean = 7,
}

impl CapeParamType {
	/// Convert from i32 to CapeParamType
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeParamType
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeParamType;
	///let v0=CapeParamType::from(0);
	///assert_eq!(v0.unwrap(),CapeParamType::CapeParameterReal);
	///let v1=CapeParamType::from(1);
	///assert_eq!(v1.unwrap(),CapeParamType::CapeParameterInteger);
	///let v2=CapeParamType::from(2);
	///assert_eq!(v2.unwrap(),CapeParamType::CapeParameterString);
	///let v3=CapeParamType::from(3);
	///assert_eq!(v3.unwrap(),CapeParamType::CapeParameterBoolean);
	///let v4=CapeParamType::from(4);
	///assert_eq!(v4.unwrap(),CapeParamType::CapeParameterArrayReal);
	///let v5=CapeParamType::from(5);
	///assert_eq!(v5.unwrap(),CapeParamType::CapeParameterArrayInteger);
	///let v6=CapeParamType::from(6);
	///assert_eq!(v6.unwrap(),CapeParamType::CapeParameterArrayString);
	///let v7=CapeParamType::from(7);
	///assert_eq!(v7.unwrap(),CapeParamType::CapeParameterArrayBoolean);
	/// ```
	pub fn from(value: i32) -> Option<CapeParamType> {
		match value {
			0 => Some(CapeParamType::CapeParameterReal),
			1 => Some(CapeParamType::CapeParameterInteger),
			2 => Some(CapeParamType::CapeParameterString),
			3 => Some(CapeParamType::CapeParameterBoolean),
			4 => Some(CapeParamType::CapeParameterArrayReal),
			5 => Some(CapeParamType::CapeParameterArrayInteger),
			6 => Some(CapeParamType::CapeParameterArrayString),
			7 => Some(CapeParamType::CapeParameterArrayBoolean),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeParameterReal => "CapeParameterReal",
			Self::CapeParameterInteger => "CapeParameterInteger",
			Self::CapeParameterString => "CapeParameterString",
			Self::CapeParameterBoolean => "CapeParameterBoolean",
			Self::CapeParameterArrayReal => "CapeParameterArrayReal",
			Self::CapeParameterArrayInteger => "CapeParameterArrayInteger",
			Self::CapeParameterArrayString => "CapeParameterArrayString",
			Self::CapeParameterArrayBoolean => "CapeParameterArrayBoolean",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeParamType;
	/// for capeParamType in CapeParamType::iter() {
	///     println!("{}={}",capeParamType,capeParamType as i32);
	/// }
	/// ```
	pub fn iter() -> CapeParamTypeIterator {
		CapeParamTypeIterator { current: 0 }
	}
}

/// CapeParamType iterator
///
/// Iterates over all CapeParamType values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeParamType;
/// for capeParamType in CapeParamType::iter() {
///     println!("{}={}",capeParamType,capeParamType as i32);
/// }
/// ```
pub struct CapeParamTypeIterator {
	current: i32,
}
impl Iterator for CapeParamTypeIterator {
	type Item = CapeParamType;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=8 {
			None
		} else {
			let result=CapeParamType::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeParamType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapeDimensionality
///
///CapeDimensionality enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeDimensionality {
	CapeMeter = 0,
	CapeKilogram = 1,
	CapeSecond = 2,
	CapeAmpere = 3,
	CapeKelvin = 4,
	CapeMole = 5,
	CapeCandela = 6,
	CapeRadian = 7,
	CapeDifferenceFlag = 8,
	CapeDimensionalityLength = 9,
}

impl CapeDimensionality {
	/// Convert from i32 to CapeDimensionality
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeDimensionality
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeDimensionality;
	///let v0=CapeDimensionality::from(0);
	///assert_eq!(v0.unwrap(),CapeDimensionality::CapeMeter);
	///let v1=CapeDimensionality::from(1);
	///assert_eq!(v1.unwrap(),CapeDimensionality::CapeKilogram);
	///let v2=CapeDimensionality::from(2);
	///assert_eq!(v2.unwrap(),CapeDimensionality::CapeSecond);
	///let v3=CapeDimensionality::from(3);
	///assert_eq!(v3.unwrap(),CapeDimensionality::CapeAmpere);
	///let v4=CapeDimensionality::from(4);
	///assert_eq!(v4.unwrap(),CapeDimensionality::CapeKelvin);
	///let v5=CapeDimensionality::from(5);
	///assert_eq!(v5.unwrap(),CapeDimensionality::CapeMole);
	///let v6=CapeDimensionality::from(6);
	///assert_eq!(v6.unwrap(),CapeDimensionality::CapeCandela);
	///let v7=CapeDimensionality::from(7);
	///assert_eq!(v7.unwrap(),CapeDimensionality::CapeRadian);
	///let v8=CapeDimensionality::from(8);
	///assert_eq!(v8.unwrap(),CapeDimensionality::CapeDifferenceFlag);
	///let v9=CapeDimensionality::from(9);
	///assert_eq!(v9.unwrap(),CapeDimensionality::CapeDimensionalityLength);
	/// ```
	pub fn from(value: i32) -> Option<CapeDimensionality> {
		match value {
			0 => Some(CapeDimensionality::CapeMeter),
			1 => Some(CapeDimensionality::CapeKilogram),
			2 => Some(CapeDimensionality::CapeSecond),
			3 => Some(CapeDimensionality::CapeAmpere),
			4 => Some(CapeDimensionality::CapeKelvin),
			5 => Some(CapeDimensionality::CapeMole),
			6 => Some(CapeDimensionality::CapeCandela),
			7 => Some(CapeDimensionality::CapeRadian),
			8 => Some(CapeDimensionality::CapeDifferenceFlag),
			9 => Some(CapeDimensionality::CapeDimensionalityLength),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeMeter => "CapeMeter",
			Self::CapeKilogram => "CapeKilogram",
			Self::CapeSecond => "CapeSecond",
			Self::CapeAmpere => "CapeAmpere",
			Self::CapeKelvin => "CapeKelvin",
			Self::CapeMole => "CapeMole",
			Self::CapeCandela => "CapeCandela",
			Self::CapeRadian => "CapeRadian",
			Self::CapeDifferenceFlag => "CapeDifferenceFlag",
			Self::CapeDimensionalityLength => "CapeDimensionalityLength",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeDimensionality;
	/// for capeDimensionality in CapeDimensionality::iter() {
	///     println!("{}={}",capeDimensionality,capeDimensionality as i32);
	/// }
	/// ```
	pub fn iter() -> CapeDimensionalityIterator {
		CapeDimensionalityIterator { current: 0 }
	}
}

/// CapeDimensionality iterator
///
/// Iterates over all CapeDimensionality values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeDimensionality;
/// for capeDimensionality in CapeDimensionality::iter() {
///     println!("{}={}",capeDimensionality,capeDimensionality as i32);
/// }
/// ```
pub struct CapeDimensionalityIterator {
	current: i32,
}
impl Iterator for CapeDimensionalityIterator {
	type Item = CapeDimensionality;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=10 {
			None
		} else {
			let result=CapeDimensionality::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeDimensionality {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapePersistedDataType
///
///CapePersistedDataType enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapePersistedDataType {
	CapePersistedReal = 0,
	CapePersistedInteger = 1,
	CapePersistedBoolean = 2,
	CapePersistedString = 3,
	CapePersistedEnumeration = 4,
	CapePersistedValue = 5,
	CapePersistedArrayReal = 6,
	CapePersistedArrayInteger = 7,
	CapePersistedArrayBoolean = 8,
	CapePersistedArrayString = 9,
	CapePersistedArrayEnumeration = 10,
	CapePersistedArrayValue = 11,
	CapePersistedArrayByte = 12,
}

impl CapePersistedDataType {
	/// Convert from i32 to CapePersistedDataType
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapePersistedDataType
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapePersistedDataType;
	///let v0=CapePersistedDataType::from(0);
	///assert_eq!(v0.unwrap(),CapePersistedDataType::CapePersistedReal);
	///let v1=CapePersistedDataType::from(1);
	///assert_eq!(v1.unwrap(),CapePersistedDataType::CapePersistedInteger);
	///let v2=CapePersistedDataType::from(2);
	///assert_eq!(v2.unwrap(),CapePersistedDataType::CapePersistedBoolean);
	///let v3=CapePersistedDataType::from(3);
	///assert_eq!(v3.unwrap(),CapePersistedDataType::CapePersistedString);
	///let v4=CapePersistedDataType::from(4);
	///assert_eq!(v4.unwrap(),CapePersistedDataType::CapePersistedEnumeration);
	///let v5=CapePersistedDataType::from(5);
	///assert_eq!(v5.unwrap(),CapePersistedDataType::CapePersistedValue);
	///let v6=CapePersistedDataType::from(6);
	///assert_eq!(v6.unwrap(),CapePersistedDataType::CapePersistedArrayReal);
	///let v7=CapePersistedDataType::from(7);
	///assert_eq!(v7.unwrap(),CapePersistedDataType::CapePersistedArrayInteger);
	///let v8=CapePersistedDataType::from(8);
	///assert_eq!(v8.unwrap(),CapePersistedDataType::CapePersistedArrayBoolean);
	///let v9=CapePersistedDataType::from(9);
	///assert_eq!(v9.unwrap(),CapePersistedDataType::CapePersistedArrayString);
	///let v10=CapePersistedDataType::from(10);
	///assert_eq!(v10.unwrap(),CapePersistedDataType::CapePersistedArrayEnumeration);
	///let v11=CapePersistedDataType::from(11);
	///assert_eq!(v11.unwrap(),CapePersistedDataType::CapePersistedArrayValue);
	///let v12=CapePersistedDataType::from(12);
	///assert_eq!(v12.unwrap(),CapePersistedDataType::CapePersistedArrayByte);
	/// ```
	pub fn from(value: i32) -> Option<CapePersistedDataType> {
		match value {
			0 => Some(CapePersistedDataType::CapePersistedReal),
			1 => Some(CapePersistedDataType::CapePersistedInteger),
			2 => Some(CapePersistedDataType::CapePersistedBoolean),
			3 => Some(CapePersistedDataType::CapePersistedString),
			4 => Some(CapePersistedDataType::CapePersistedEnumeration),
			5 => Some(CapePersistedDataType::CapePersistedValue),
			6 => Some(CapePersistedDataType::CapePersistedArrayReal),
			7 => Some(CapePersistedDataType::CapePersistedArrayInteger),
			8 => Some(CapePersistedDataType::CapePersistedArrayBoolean),
			9 => Some(CapePersistedDataType::CapePersistedArrayString),
			10 => Some(CapePersistedDataType::CapePersistedArrayEnumeration),
			11 => Some(CapePersistedDataType::CapePersistedArrayValue),
			12 => Some(CapePersistedDataType::CapePersistedArrayByte),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapePersistedReal => "CapePersistedReal",
			Self::CapePersistedInteger => "CapePersistedInteger",
			Self::CapePersistedBoolean => "CapePersistedBoolean",
			Self::CapePersistedString => "CapePersistedString",
			Self::CapePersistedEnumeration => "CapePersistedEnumeration",
			Self::CapePersistedValue => "CapePersistedValue",
			Self::CapePersistedArrayReal => "CapePersistedArrayReal",
			Self::CapePersistedArrayInteger => "CapePersistedArrayInteger",
			Self::CapePersistedArrayBoolean => "CapePersistedArrayBoolean",
			Self::CapePersistedArrayString => "CapePersistedArrayString",
			Self::CapePersistedArrayEnumeration => "CapePersistedArrayEnumeration",
			Self::CapePersistedArrayValue => "CapePersistedArrayValue",
			Self::CapePersistedArrayByte => "CapePersistedArrayByte",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapePersistedDataType;
	/// for capePersistedDataType in CapePersistedDataType::iter() {
	///     println!("{}={}",capePersistedDataType,capePersistedDataType as i32);
	/// }
	/// ```
	pub fn iter() -> CapePersistedDataTypeIterator {
		CapePersistedDataTypeIterator { current: 0 }
	}
}

/// CapePersistedDataType iterator
///
/// Iterates over all CapePersistedDataType values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapePersistedDataType;
/// for capePersistedDataType in CapePersistedDataType::iter() {
///     println!("{}={}",capePersistedDataType,capePersistedDataType as i32);
/// }
/// ```
pub struct CapePersistedDataTypeIterator {
	current: i32,
}
impl Iterator for CapePersistedDataTypeIterator {
	type Item = CapePersistedDataType;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=13 {
			None
		} else {
			let result=CapePersistedDataType::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapePersistedDataType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapeParamMode
///
///CapeParamMode enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeParamMode {
	CapeInput = 1,
	CapeOutput = 2,
	CapeInputOutput = 3,
}

impl CapeParamMode {
	/// Convert from i32 to CapeParamMode
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeParamMode
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeParamMode;
	///let v0=CapeParamMode::from(1);
	///assert_eq!(v0.unwrap(),CapeParamMode::CapeInput);
	///let v1=CapeParamMode::from(2);
	///assert_eq!(v1.unwrap(),CapeParamMode::CapeOutput);
	///let v2=CapeParamMode::from(3);
	///assert_eq!(v2.unwrap(),CapeParamMode::CapeInputOutput);
	/// ```
	pub fn from(value: i32) -> Option<CapeParamMode> {
		match value {
			1 => Some(CapeParamMode::CapeInput),
			2 => Some(CapeParamMode::CapeOutput),
			3 => Some(CapeParamMode::CapeInputOutput),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeInput => "CapeInput",
			Self::CapeOutput => "CapeOutput",
			Self::CapeInputOutput => "CapeInputOutput",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeParamMode;
	/// for capeParamMode in CapeParamMode::iter() {
	///     println!("{}={}",capeParamMode,capeParamMode as i32);
	/// }
	/// ```
	pub fn iter() -> CapeParamModeIterator {
		CapeParamModeIterator { current: 0 }
	}
}

/// CapeParamMode iterator
///
/// Iterates over all CapeParamMode values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeParamMode;
/// for capeParamMode in CapeParamMode::iter() {
///     println!("{}={}",capeParamMode,capeParamMode as i32);
/// }
/// ```
pub struct CapeParamModeIterator {
	current: i32,
}
impl Iterator for CapeParamModeIterator {
	type Item = CapeParamMode;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=3 {
			None
		} else {
			let result=CapeParamMode::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeParamMode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapeValidationStatus
///
///CapeValidationStatus enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeValidationStatus {
	CapeNotValidated = 0,
	CapeInvalid = 1,
	CapeValid = 2,
}

impl CapeValidationStatus {
	/// Convert from i32 to CapeValidationStatus
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeValidationStatus
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeValidationStatus;
	///let v0=CapeValidationStatus::from(0);
	///assert_eq!(v0.unwrap(),CapeValidationStatus::CapeNotValidated);
	///let v1=CapeValidationStatus::from(1);
	///assert_eq!(v1.unwrap(),CapeValidationStatus::CapeInvalid);
	///let v2=CapeValidationStatus::from(2);
	///assert_eq!(v2.unwrap(),CapeValidationStatus::CapeValid);
	/// ```
	pub fn from(value: i32) -> Option<CapeValidationStatus> {
		match value {
			0 => Some(CapeValidationStatus::CapeNotValidated),
			1 => Some(CapeValidationStatus::CapeInvalid),
			2 => Some(CapeValidationStatus::CapeValid),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeNotValidated => "CapeNotValidated",
			Self::CapeInvalid => "CapeInvalid",
			Self::CapeValid => "CapeValid",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeValidationStatus;
	/// for capeValidationStatus in CapeValidationStatus::iter() {
	///     println!("{}={}",capeValidationStatus,capeValidationStatus as i32);
	/// }
	/// ```
	pub fn iter() -> CapeValidationStatusIterator {
		CapeValidationStatusIterator { current: 0 }
	}
}

/// CapeValidationStatus iterator
///
/// Iterates over all CapeValidationStatus values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeValidationStatus;
/// for capeValidationStatus in CapeValidationStatus::iter() {
///     println!("{}={}",capeValidationStatus,capeValidationStatus as i32);
/// }
/// ```
pub struct CapeValidationStatusIterator {
	current: i32,
}
impl Iterator for CapeValidationStatusIterator {
	type Item = CapeValidationStatus;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=3 {
			None
		} else {
			let result=CapeValidationStatus::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeValidationStatus {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapeCalculationCode
///
///CapeCalculationCode enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeCalculationCode {
	CapeNoCalculation = 0,
	CapeLogFugacityCoefficients = 1,
	CapeTDerivative = 2,
	CapePDerivative = 4,
	CapeMoleNumbersDerivatives = 8,
}

impl CapeCalculationCode {
	/// Convert from i32 to CapeCalculationCode
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeCalculationCode
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeCalculationCode;
	///let v0=CapeCalculationCode::from(0);
	///assert_eq!(v0.unwrap(),CapeCalculationCode::CapeNoCalculation);
	///let v1=CapeCalculationCode::from(1);
	///assert_eq!(v1.unwrap(),CapeCalculationCode::CapeLogFugacityCoefficients);
	///let v2=CapeCalculationCode::from(2);
	///assert_eq!(v2.unwrap(),CapeCalculationCode::CapeTDerivative);
	///let v3=CapeCalculationCode::from(4);
	///assert_eq!(v3.unwrap(),CapeCalculationCode::CapePDerivative);
	///let v4=CapeCalculationCode::from(8);
	///assert_eq!(v4.unwrap(),CapeCalculationCode::CapeMoleNumbersDerivatives);
	/// ```
	pub fn from(value: i32) -> Option<CapeCalculationCode> {
		match value {
			0 => Some(CapeCalculationCode::CapeNoCalculation),
			1 => Some(CapeCalculationCode::CapeLogFugacityCoefficients),
			2 => Some(CapeCalculationCode::CapeTDerivative),
			4 => Some(CapeCalculationCode::CapePDerivative),
			8 => Some(CapeCalculationCode::CapeMoleNumbersDerivatives),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeNoCalculation => "CapeNoCalculation",
			Self::CapeLogFugacityCoefficients => "CapeLogFugacityCoefficients",
			Self::CapeTDerivative => "CapeTDerivative",
			Self::CapePDerivative => "CapePDerivative",
			Self::CapeMoleNumbersDerivatives => "CapeMoleNumbersDerivatives",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeCalculationCode;
	/// for capeCalculationCode in CapeCalculationCode::iter() {
	///     println!("{}={}",capeCalculationCode,capeCalculationCode as i32);
	/// }
	/// ```
	pub fn iter() -> CapeCalculationCodeIterator {
		CapeCalculationCodeIterator { current: 0 }
	}
}

/// CapeCalculationCode iterator
///
/// Iterates over all CapeCalculationCode values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeCalculationCode;
/// for capeCalculationCode in CapeCalculationCode::iter() {
///     println!("{}={}",capeCalculationCode,capeCalculationCode as i32);
/// }
/// ```
pub struct CapeCalculationCodeIterator {
	current: i32,
}
impl Iterator for CapeCalculationCodeIterator {
	type Item = CapeCalculationCode;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=5 {
			None
		} else {
			let result=CapeCalculationCode::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeCalculationCode {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapePhaseStatus
///
///CapePhaseStatus enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapePhaseStatus {
	CapeUnknownphasestatus = 0,
	CapeAtequilibrium = 1,
	CapeEstimates = 2,
}

impl CapePhaseStatus {
	/// Convert from i32 to CapePhaseStatus
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapePhaseStatus
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapePhaseStatus;
	///let v0=CapePhaseStatus::from(0);
	///assert_eq!(v0.unwrap(),CapePhaseStatus::CapeUnknownphasestatus);
	///let v1=CapePhaseStatus::from(1);
	///assert_eq!(v1.unwrap(),CapePhaseStatus::CapeAtequilibrium);
	///let v2=CapePhaseStatus::from(2);
	///assert_eq!(v2.unwrap(),CapePhaseStatus::CapeEstimates);
	/// ```
	pub fn from(value: i32) -> Option<CapePhaseStatus> {
		match value {
			0 => Some(CapePhaseStatus::CapeUnknownphasestatus),
			1 => Some(CapePhaseStatus::CapeAtequilibrium),
			2 => Some(CapePhaseStatus::CapeEstimates),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeUnknownphasestatus => "CapeUnknownphasestatus",
			Self::CapeAtequilibrium => "CapeAtequilibrium",
			Self::CapeEstimates => "CapeEstimates",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapePhaseStatus;
	/// for capePhaseStatus in CapePhaseStatus::iter() {
	///     println!("{}={}",capePhaseStatus,capePhaseStatus as i32);
	/// }
	/// ```
	pub fn iter() -> CapePhaseStatusIterator {
		CapePhaseStatusIterator { current: 0 }
	}
}

/// CapePhaseStatus iterator
///
/// Iterates over all CapePhaseStatus values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapePhaseStatus;
/// for capePhaseStatus in CapePhaseStatus::iter() {
///     println!("{}={}",capePhaseStatus,capePhaseStatus as i32);
/// }
/// ```
pub struct CapePhaseStatusIterator {
	current: i32,
}
impl Iterator for CapePhaseStatusIterator {
	type Item = CapePhaseStatus;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=3 {
			None
		} else {
			let result=CapePhaseStatus::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapePhaseStatus {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapeEditResult
///
///CapeEditResult enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeEditResult {
	CapeModified = 0,
	CapeNotModified = 1,
}

impl CapeEditResult {
	/// Convert from i32 to CapeEditResult
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeEditResult
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeEditResult;
	///let v0=CapeEditResult::from(0);
	///assert_eq!(v0.unwrap(),CapeEditResult::CapeModified);
	///let v1=CapeEditResult::from(1);
	///assert_eq!(v1.unwrap(),CapeEditResult::CapeNotModified);
	/// ```
	pub fn from(value: i32) -> Option<CapeEditResult> {
		match value {
			0 => Some(CapeEditResult::CapeModified),
			1 => Some(CapeEditResult::CapeNotModified),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeModified => "CapeModified",
			Self::CapeNotModified => "CapeNotModified",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeEditResult;
	/// for capeEditResult in CapeEditResult::iter() {
	///     println!("{}={}",capeEditResult,capeEditResult as i32);
	/// }
	/// ```
	pub fn iter() -> CapeEditResultIterator {
		CapeEditResultIterator { current: 0 }
	}
}

/// CapeEditResult iterator
///
/// Iterates over all CapeEditResult values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeEditResult;
/// for capeEditResult in CapeEditResult::iter() {
///     println!("{}={}",capeEditResult,capeEditResult as i32);
/// }
/// ```
pub struct CapeEditResultIterator {
	current: i32,
}
impl Iterator for CapeEditResultIterator {
	type Item = CapeEditResult;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=2 {
			None
		} else {
			let result=CapeEditResult::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeEditResult {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapePortType
///
///CapePortType enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapePortType {
	CapeMaterial = 0,
	CapeEnergy = 1,
	CapeInformation = 2,
	CapeAny = 3,
}

impl CapePortType {
	/// Convert from i32 to CapePortType
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapePortType
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapePortType;
	///let v0=CapePortType::from(0);
	///assert_eq!(v0.unwrap(),CapePortType::CapeMaterial);
	///let v1=CapePortType::from(1);
	///assert_eq!(v1.unwrap(),CapePortType::CapeEnergy);
	///let v2=CapePortType::from(2);
	///assert_eq!(v2.unwrap(),CapePortType::CapeInformation);
	///let v3=CapePortType::from(3);
	///assert_eq!(v3.unwrap(),CapePortType::CapeAny);
	/// ```
	pub fn from(value: i32) -> Option<CapePortType> {
		match value {
			0 => Some(CapePortType::CapeMaterial),
			1 => Some(CapePortType::CapeEnergy),
			2 => Some(CapePortType::CapeInformation),
			3 => Some(CapePortType::CapeAny),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeMaterial => "CapeMaterial",
			Self::CapeEnergy => "CapeEnergy",
			Self::CapeInformation => "CapeInformation",
			Self::CapeAny => "CapeAny",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapePortType;
	/// for capePortType in CapePortType::iter() {
	///     println!("{}={}",capePortType,capePortType as i32);
	/// }
	/// ```
	pub fn iter() -> CapePortTypeIterator {
		CapePortTypeIterator { current: 0 }
	}
}

/// CapePortType iterator
///
/// Iterates over all CapePortType values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapePortType;
/// for capePortType in CapePortType::iter() {
///     println!("{}={}",capePortType,capePortType as i32);
/// }
/// ```
pub struct CapePortTypeIterator {
	current: i32,
}
impl Iterator for CapePortTypeIterator {
	type Item = CapePortType;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=4 {
			None
		} else {
			let result=CapePortType::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapePortType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapePortDirection
///
///CapePortDirection enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapePortDirection {
	CapeInlet = 0,
	CapeOutlet = 1,
	CapeInletOutlet = 2,
}

impl CapePortDirection {
	/// Convert from i32 to CapePortDirection
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapePortDirection
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapePortDirection;
	///let v0=CapePortDirection::from(0);
	///assert_eq!(v0.unwrap(),CapePortDirection::CapeInlet);
	///let v1=CapePortDirection::from(1);
	///assert_eq!(v1.unwrap(),CapePortDirection::CapeOutlet);
	///let v2=CapePortDirection::from(2);
	///assert_eq!(v2.unwrap(),CapePortDirection::CapeInletOutlet);
	/// ```
	pub fn from(value: i32) -> Option<CapePortDirection> {
		match value {
			0 => Some(CapePortDirection::CapeInlet),
			1 => Some(CapePortDirection::CapeOutlet),
			2 => Some(CapePortDirection::CapeInletOutlet),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeInlet => "CapeInlet",
			Self::CapeOutlet => "CapeOutlet",
			Self::CapeInletOutlet => "CapeInletOutlet",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapePortDirection;
	/// for capePortDirection in CapePortDirection::iter() {
	///     println!("{}={}",capePortDirection,capePortDirection as i32);
	/// }
	/// ```
	pub fn iter() -> CapePortDirectionIterator {
		CapePortDirectionIterator { current: 0 }
	}
}

/// CapePortDirection iterator
///
/// Iterates over all CapePortDirection values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapePortDirection;
/// for capePortDirection in CapePortDirection::iter() {
///     println!("{}={}",capePortDirection,capePortDirection as i32);
/// }
/// ```
pub struct CapePortDirectionIterator {
	current: i32,
}
impl Iterator for CapePortDirectionIterator {
	type Item = CapePortDirection;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=3 {
			None
		} else {
			let result=CapePortDirection::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapePortDirection {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapeSolutionStatus
///
///CapeSolutionStatus enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeSolutionStatus {
	CapeSolved = 0,
	CapeNotSolved = 1,
}

impl CapeSolutionStatus {
	/// Convert from i32 to CapeSolutionStatus
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeSolutionStatus
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeSolutionStatus;
	///let v0=CapeSolutionStatus::from(0);
	///assert_eq!(v0.unwrap(),CapeSolutionStatus::CapeSolved);
	///let v1=CapeSolutionStatus::from(1);
	///assert_eq!(v1.unwrap(),CapeSolutionStatus::CapeNotSolved);
	/// ```
	pub fn from(value: i32) -> Option<CapeSolutionStatus> {
		match value {
			0 => Some(CapeSolutionStatus::CapeSolved),
			1 => Some(CapeSolutionStatus::CapeNotSolved),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeSolved => "CapeSolved",
			Self::CapeNotSolved => "CapeNotSolved",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeSolutionStatus;
	/// for capeSolutionStatus in CapeSolutionStatus::iter() {
	///     println!("{}={}",capeSolutionStatus,capeSolutionStatus as i32);
	/// }
	/// ```
	pub fn iter() -> CapeSolutionStatusIterator {
		CapeSolutionStatusIterator { current: 0 }
	}
}

/// CapeSolutionStatus iterator
///
/// Iterates over all CapeSolutionStatus values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeSolutionStatus;
/// for capeSolutionStatus in CapeSolutionStatus::iter() {
///     println!("{}={}",capeSolutionStatus,capeSolutionStatus as i32);
/// }
/// ```
pub struct CapeSolutionStatusIterator {
	current: i32,
}
impl Iterator for CapeSolutionStatusIterator {
	type Item = CapeSolutionStatus;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=2 {
			None
		} else {
			let result=CapeSolutionStatus::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeSolutionStatus {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapeStreamType
///
///CapeStreamType enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeStreamType {
	CapeAnyStreams = 0,
	CapeMaterialStream = 1,
	CapeEnergyStream = 2,
	CapeInformationStream = 3,
}

impl CapeStreamType {
	/// Convert from i32 to CapeStreamType
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeStreamType
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeStreamType;
	///let v0=CapeStreamType::from(0);
	///assert_eq!(v0.unwrap(),CapeStreamType::CapeAnyStreams);
	///let v1=CapeStreamType::from(1);
	///assert_eq!(v1.unwrap(),CapeStreamType::CapeMaterialStream);
	///let v2=CapeStreamType::from(2);
	///assert_eq!(v2.unwrap(),CapeStreamType::CapeEnergyStream);
	///let v3=CapeStreamType::from(3);
	///assert_eq!(v3.unwrap(),CapeStreamType::CapeInformationStream);
	/// ```
	pub fn from(value: i32) -> Option<CapeStreamType> {
		match value {
			0 => Some(CapeStreamType::CapeAnyStreams),
			1 => Some(CapeStreamType::CapeMaterialStream),
			2 => Some(CapeStreamType::CapeEnergyStream),
			3 => Some(CapeStreamType::CapeInformationStream),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeAnyStreams => "CapeAnyStreams",
			Self::CapeMaterialStream => "CapeMaterialStream",
			Self::CapeEnergyStream => "CapeEnergyStream",
			Self::CapeInformationStream => "CapeInformationStream",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeStreamType;
	/// for capeStreamType in CapeStreamType::iter() {
	///     println!("{}={}",capeStreamType,capeStreamType as i32);
	/// }
	/// ```
	pub fn iter() -> CapeStreamTypeIterator {
		CapeStreamTypeIterator { current: 0 }
	}
}

/// CapeStreamType iterator
///
/// Iterates over all CapeStreamType values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeStreamType;
/// for capeStreamType in CapeStreamType::iter() {
///     println!("{}={}",capeStreamType,capeStreamType as i32);
/// }
/// ```
pub struct CapeStreamTypeIterator {
	current: i32,
}
impl Iterator for CapeStreamTypeIterator {
	type Item = CapeStreamType;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=4 {
			None
		} else {
			let result=CapeStreamType::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeStreamType {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}
///CapeMonitoringEvent
///
///CapeMonitoringEvent enumeration
///
#[repr(i32)]
#[derive(Debug,PartialEq,Eq,Clone,Copy)]
pub enum CapeMonitoringEvent {
	CapeUnitOperationAdded = 0,
	CapeUnitOperationRenamed = 1,
	CapeUnitOperationRemoved = 2,
	CapeStreamAdded = 3,
	CapeStreamRenamed = 4,
	CapeStreamRemoved = 5,
	CapeConnectionChanged = 6,
	CapeFlowsheetSolutionStatusChanged = 7,
	CapeNextTimeStep = 8,
	CapeFlowsheetValidationStatusChanged = 9,
}

impl CapeMonitoringEvent {
	/// Convert from i32 to CapeMonitoringEvent
	///
	/// # Arguments
	///
	/// * `value` - i32 value to be converted to CapeMonitoringEvent
	///
	/// # Examples
	///
	/// ```
	///use cobia::*;
	///use cape_open_1_2::CapeMonitoringEvent;
	///let v0=CapeMonitoringEvent::from(0);
	///assert_eq!(v0.unwrap(),CapeMonitoringEvent::CapeUnitOperationAdded);
	///let v1=CapeMonitoringEvent::from(1);
	///assert_eq!(v1.unwrap(),CapeMonitoringEvent::CapeUnitOperationRenamed);
	///let v2=CapeMonitoringEvent::from(2);
	///assert_eq!(v2.unwrap(),CapeMonitoringEvent::CapeUnitOperationRemoved);
	///let v3=CapeMonitoringEvent::from(3);
	///assert_eq!(v3.unwrap(),CapeMonitoringEvent::CapeStreamAdded);
	///let v4=CapeMonitoringEvent::from(4);
	///assert_eq!(v4.unwrap(),CapeMonitoringEvent::CapeStreamRenamed);
	///let v5=CapeMonitoringEvent::from(5);
	///assert_eq!(v5.unwrap(),CapeMonitoringEvent::CapeStreamRemoved);
	///let v6=CapeMonitoringEvent::from(6);
	///assert_eq!(v6.unwrap(),CapeMonitoringEvent::CapeConnectionChanged);
	///let v7=CapeMonitoringEvent::from(7);
	///assert_eq!(v7.unwrap(),CapeMonitoringEvent::CapeFlowsheetSolutionStatusChanged);
	///let v8=CapeMonitoringEvent::from(8);
	///assert_eq!(v8.unwrap(),CapeMonitoringEvent::CapeNextTimeStep);
	///let v9=CapeMonitoringEvent::from(9);
	///assert_eq!(v9.unwrap(),CapeMonitoringEvent::CapeFlowsheetValidationStatusChanged);
	/// ```
	pub fn from(value: i32) -> Option<CapeMonitoringEvent> {
		match value {
			0 => Some(CapeMonitoringEvent::CapeUnitOperationAdded),
			1 => Some(CapeMonitoringEvent::CapeUnitOperationRenamed),
			2 => Some(CapeMonitoringEvent::CapeUnitOperationRemoved),
			3 => Some(CapeMonitoringEvent::CapeStreamAdded),
			4 => Some(CapeMonitoringEvent::CapeStreamRenamed),
			5 => Some(CapeMonitoringEvent::CapeStreamRemoved),
			6 => Some(CapeMonitoringEvent::CapeConnectionChanged),
			7 => Some(CapeMonitoringEvent::CapeFlowsheetSolutionStatusChanged),
			8 => Some(CapeMonitoringEvent::CapeNextTimeStep),
			9 => Some(CapeMonitoringEvent::CapeFlowsheetValidationStatusChanged),
			_ => None,
		}
	}
	/// Convert to string
	pub fn as_string(&self) -> &str {
		match self {
			Self::CapeUnitOperationAdded => "CapeUnitOperationAdded",
			Self::CapeUnitOperationRenamed => "CapeUnitOperationRenamed",
			Self::CapeUnitOperationRemoved => "CapeUnitOperationRemoved",
			Self::CapeStreamAdded => "CapeStreamAdded",
			Self::CapeStreamRenamed => "CapeStreamRenamed",
			Self::CapeStreamRemoved => "CapeStreamRemoved",
			Self::CapeConnectionChanged => "CapeConnectionChanged",
			Self::CapeFlowsheetSolutionStatusChanged => "CapeFlowsheetSolutionStatusChanged",
			Self::CapeNextTimeStep => "CapeNextTimeStep",
			Self::CapeFlowsheetValidationStatusChanged => "CapeFlowsheetValidationStatusChanged",
		}
	}
	///get an iterator
	///
	/// # Examples
	///
	/// ```
	/// use cobia::*;
	/// use cape_open_1_2::CapeMonitoringEvent;
	/// for capeMonitoringEvent in CapeMonitoringEvent::iter() {
	///     println!("{}={}",capeMonitoringEvent,capeMonitoringEvent as i32);
	/// }
	/// ```
	pub fn iter() -> CapeMonitoringEventIterator {
		CapeMonitoringEventIterator { current: 0 }
	}
}

/// CapeMonitoringEvent iterator
///
/// Iterates over all CapeMonitoringEvent values
///
/// # Examples
///
/// ```
/// use cobia::*;
/// use cape_open_1_2::CapeMonitoringEvent;
/// for capeMonitoringEvent in CapeMonitoringEvent::iter() {
///     println!("{}={}",capeMonitoringEvent,capeMonitoringEvent as i32);
/// }
/// ```
pub struct CapeMonitoringEventIterator {
	current: i32,
}
impl Iterator for CapeMonitoringEventIterator {
	type Item = CapeMonitoringEvent;
	fn next(&mut self) -> Option<Self::Item> {
		if self.current>=10 {
			None
		} else {
			let result=CapeMonitoringEvent::from(self.current);
			self.current+=1;
			result
		}
	}
}
impl fmt::Display for CapeMonitoringEvent {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f,"{}",self.as_string())
	}
}

//Interfaces

///ICapeIdentification
///
///ICapeIdentification interface
///
pub trait ICapeIdentification {
	fn get_component_name(&mut self,name:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn set_component_name(&mut self,name:&CapeStringIn) -> Result<(),COBIAError>;
	fn get_component_description(&mut self,desc:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn set_component_description(&mut self,desc:&CapeStringIn) -> Result<(),COBIAError>;
}

pub trait ICapeIdentificationImpl : ICapeIdentification {
	type T: ICapeInterfaceImpl+ICapeIdentificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeIdentification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeIdentification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeIdentificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeIdentification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeIdentification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeIdentification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_component_name(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if name.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if name.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut name=unsafe{*((&name as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut name=CapeStringOut::new(&mut name);
		match myself.get_component_name(&mut name) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeIdentification::GetComponentName")
		}
	}

	extern "C" fn raw_set_component_name(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let name=CapeStringIn::new(&name);
		match myself.set_component_name(&name) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeIdentification::SetComponentName")
		}
	}

	extern "C" fn raw_get_component_description(me: *mut std::ffi::c_void,desc:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if desc.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if desc.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut desc=unsafe{*((&desc as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut desc=CapeStringOut::new(&mut desc);
		match myself.get_component_description(&mut desc) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeIdentification::GetComponentDescription")
		}
	}

	extern "C" fn raw_set_component_description(me: *mut std::ffi::c_void,desc:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let desc=CapeStringIn::new(&desc);
		match myself.set_component_description(&desc) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeIdentification::SetComponentDescription")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeIdentification_VTable =
		C::CAPEOPEN_1_2_ICapeIdentification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getComponentName: Some(Self::T::raw_get_component_name),
			putComponentName: Some(Self::T::raw_set_component_name),
			getComponentDescription: Some(Self::T::raw_get_component_description),
			putComponentDescription: Some(Self::T::raw_set_component_description),
		};
}

#[cape_smart_pointer(ICAPEIDENTIFICATION_UUID)]
pub struct CapeIdentification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeIdentification,
}

impl CapeIdentification {

	pub fn get_component_name<TypeOfName:CapeStringProviderOut>(&self,name:&mut TypeOfName) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getComponentName.unwrap())((*self.interface).me,(&name.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_component_name<TypeOfName:CapeStringProviderIn>(&self,name:&TypeOfName) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putComponentName.unwrap())((*self.interface).me,(&name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_component_description<TypeOfDesc:CapeStringProviderOut>(&self,desc:&mut TypeOfDesc) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getComponentDescription.unwrap())((*self.interface).me,(&desc.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_component_description<TypeOfDesc:CapeStringProviderIn>(&self,desc:&TypeOfDesc) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putComponentDescription.unwrap())((*self.interface).me,(&desc.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeCollection
///
///ICapeCollection interface
///
pub trait ICapeCollection<CollectionItem:CapeSmartPointer> {
	fn item_by_index(&mut self,index:CapeInteger) -> Result<CollectionItem,COBIAError>;
	fn item_by_name(&mut self,name:&CapeStringIn) -> Result<CollectionItem,COBIAError>;
	fn get_count(&mut self) -> Result<CapeInteger,COBIAError>;
}

pub trait ICapeCollectionImpl<CollectionItem:CapeSmartPointer> : ICapeCollection<CollectionItem> {
	type T: ICapeInterfaceImpl+ICapeCollectionImpl<CollectionItem>;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeCollection interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeCollection_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeCollectionImpl<CollectionItem>+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeCollection =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeCollection;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeCollection_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_item_by_index(me: *mut std::ffi::c_void,index:CapeInteger,item:*mut *mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if item.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if item.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		match myself.item_by_index(index) {
			Ok(_item) => {
				unsafe{*item=_item.detach() as *mut crate::C::ICapeInterface;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeCollection::ItemByIndex")
		}
	}

	extern "C" fn raw_item_by_name(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString,item:*mut *mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if item.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if item.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let name=CapeStringIn::new(&name);
		match myself.item_by_name(&name) {
			Ok(_item) => {
				unsafe{*item=_item.detach() as *mut crate::C::ICapeInterface;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeCollection::ItemByName")
		}
	}

	extern "C" fn raw_get_count(me: *mut std::ffi::c_void,item_count:*mut CapeInteger) -> crate::C::CapeResult {
		if item_count.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_count() {
			Ok(_item_count) => {
				unsafe{*item_count=_item_count;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeCollection::GetCount")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeCollection_VTable =
		C::CAPEOPEN_1_2_ICapeCollection_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			ItemByIndex: Some(Self::T::raw_item_by_index),
			ItemByName: Some(Self::T::raw_item_by_name),
			getCount: Some(Self::T::raw_get_count),
		};
}

#[cape_smart_pointer(ICAPECOLLECTION_UUID)]
pub struct CapeCollection<CollectionItem:CapeSmartPointer> {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeCollection,
	phantom_collection_item : PhantomData<CollectionItem>,
}

impl<CollectionItem:CapeSmartPointer> CapeCollection<CollectionItem> {

	pub fn item_by_index(&self,index:CapeInteger) -> Result<CollectionItem,COBIAError> {
		let mut item: *mut crate::C::ICapeInterface=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).ItemByIndex.unwrap())((*self.interface).me,index,&mut item as *mut *mut crate::C::ICapeInterface)
		};
		let item=crate::CapeObject::attach(item);
		let item=match CollectionItem::from_object(&item) {
			Ok(_item) => _item,
			Err(e) => {return Err(e);}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(item)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn item_by_name<TypeOfName:CapeStringProviderIn>(&self,name:&TypeOfName) -> Result<CollectionItem,COBIAError> {
		let mut item: *mut crate::C::ICapeInterface=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).ItemByName.unwrap())((*self.interface).me,(&name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut item as *mut *mut crate::C::ICapeInterface)
		};
		let item=crate::CapeObject::attach(item);
		let item=match CollectionItem::from_object(&item) {
			Ok(_item) => _item,
			Err(e) => {return Err(e);}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(item)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_count(&self) -> Result<CapeInteger,COBIAError> {
		let mut item_count:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getCount.unwrap())((*self.interface).me,&mut item_count as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(item_count)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeParameter
///
///ICapeParameter interface
///
pub trait ICapeParameter {
	fn get_val_status(&mut self) -> Result<CapeValidationStatus,COBIAError>;
	fn get_mode(&mut self) -> Result<CapeParamMode,COBIAError>;
	fn get_type(&mut self) -> Result<CapeParamType,COBIAError>;
	fn validate(&mut self,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn reset(&mut self) -> Result<(),COBIAError>;
}

pub trait ICapeParameterImpl : ICapeParameter {
	type T: ICapeInterfaceImpl+ICapeParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_val_status(me: *mut std::ffi::c_void,val_status:*mut C::CAPEOPEN_1_2_CapeValidationStatus) -> crate::C::CapeResult {
		if val_status.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_val_status() {
			Ok(_val_status) => {
				unsafe{*val_status=_val_status as C::CAPEOPEN_1_2_CapeValidationStatus;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeParameter::GetValStatus")
		}
	}

	extern "C" fn raw_get_mode(me: *mut std::ffi::c_void,mode:*mut C::CAPEOPEN_1_2_CapeParamMode) -> crate::C::CapeResult {
		if mode.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_mode() {
			Ok(_mode) => {
				unsafe{*mode=_mode as C::CAPEOPEN_1_2_CapeParamMode;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeParameter::GetMode")
		}
	}

	extern "C" fn raw_get_type(me: *mut std::ffi::c_void,parameter_type:*mut C::CAPEOPEN_1_2_CapeParamType) -> crate::C::CapeResult {
		if parameter_type.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_type() {
			Ok(_parameter_type) => {
				unsafe{*parameter_type=_parameter_type as C::CAPEOPEN_1_2_CapeParamType;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeParameter::GetType")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeParameter::Validate")
		}
	}

	extern "C" fn raw_reset(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.reset() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeParameter::Reset")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeParameter_VTable =
		C::CAPEOPEN_1_2_ICapeParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValStatus: Some(Self::T::raw_get_val_status),
			getMode: Some(Self::T::raw_get_mode),
			getType: Some(Self::T::raw_get_type),
			Validate: Some(Self::T::raw_validate),
			Reset: Some(Self::T::raw_reset),
		};
}

#[cape_smart_pointer(ICAPEPARAMETER_UUID)]
pub struct CapeParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeParameter,
}

impl CapeParameter {

	pub fn get_val_status(&self) -> Result<CapeValidationStatus,COBIAError> {
		let mut val_status:C::CAPEOPEN_1_2_CapeValidationStatus=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValStatus.unwrap())((*self.interface).me,&mut val_status as *mut C::CAPEOPEN_1_2_CapeValidationStatus)
		};
		let val_status=match CapeValidationStatus::from(val_status) {
			Some(_val_status) => _val_status,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(val_status)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_mode(&self) -> Result<CapeParamMode,COBIAError> {
		let mut mode:C::CAPEOPEN_1_2_CapeParamMode=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getMode.unwrap())((*self.interface).me,&mut mode as *mut C::CAPEOPEN_1_2_CapeParamMode)
		};
		let mode=match CapeParamMode::from(mode) {
			Some(_mode) => _mode,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(mode)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_type(&self) -> Result<CapeParamType,COBIAError> {
		let mut parameter_type:C::CAPEOPEN_1_2_CapeParamType=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getType.unwrap())((*self.interface).me,&mut parameter_type as *mut C::CAPEOPEN_1_2_CapeParamType)
		};
		let parameter_type=match CapeParamType::from(parameter_type) {
			Some(_parameter_type) => _parameter_type,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(parameter_type)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn reset(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Reset.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeRealParameter
///
///ICapeRealParameter interface
///
pub trait ICapeRealParameter {
	fn get_value(&mut self) -> Result<CapeReal,COBIAError>;
	fn set_value(&mut self,value:CapeReal) -> Result<(),COBIAError>;
	fn get_default_value(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_lower_bound(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_upper_bound(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_dimensionality(&mut self,dimensionality:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn validate(&mut self,value:CapeReal,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeRealParameterImpl : ICapeRealParameter {
	type T: ICapeInterfaceImpl+ICapeRealParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeRealParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeRealParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeRealParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeRealParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeRealParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeRealParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value:*mut CapeReal) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_value() {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameter::GetValue")
		}
	}

	extern "C" fn raw_set_value(me: *mut std::ffi::c_void,value:CapeReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.set_value(value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeRealParameter::SetValue")
		}
	}

	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeReal) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameter::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_lower_bound(me: *mut std::ffi::c_void,l_bound:*mut CapeReal) -> crate::C::CapeResult {
		if l_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_lower_bound() {
			Ok(_l_bound) => {
				unsafe{*l_bound=_l_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameter::GetLowerBound")
		}
	}

	extern "C" fn raw_get_upper_bound(me: *mut std::ffi::c_void,u_bound:*mut CapeReal) -> crate::C::CapeResult {
		if u_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_upper_bound() {
			Ok(_u_bound) => {
				unsafe{*u_bound=_u_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameter::GetUpperBound")
		}
	}

	extern "C" fn raw_get_dimensionality(me: *mut std::ffi::c_void,dimensionality:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if dimensionality.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if dimensionality.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut dimensionality=unsafe{*((&dimensionality as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut dimensionality=CapeArrayRealOut::new(&mut dimensionality);
		match myself.get_dimensionality(&mut dimensionality) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeRealParameter::GetDimensionality")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:CapeReal,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameter::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeRealParameter_VTable =
		C::CAPEOPEN_1_2_ICapeRealParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValue: Some(Self::T::raw_get_value),
			putValue: Some(Self::T::raw_set_value),
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getLowerBound: Some(Self::T::raw_get_lower_bound),
			getUpperBound: Some(Self::T::raw_get_upper_bound),
			getDimensionality: Some(Self::T::raw_get_dimensionality),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEREALPARAMETER_UUID)]
pub struct CapeRealParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeRealParameter,
}

impl CapeRealParameter {

	pub fn get_value(&self) -> Result<CapeReal,COBIAError> {
		let mut value:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValue.unwrap())((*self.interface).me,&mut value as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_value(&self,value:CapeReal) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putValue.unwrap())((*self.interface).me,value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_default_value(&self) -> Result<CapeReal,COBIAError> {
		let mut default_value:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_lower_bound(&self) -> Result<CapeReal,COBIAError> {
		let mut l_bound:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getLowerBound.unwrap())((*self.interface).me,&mut l_bound as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(l_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upper_bound(&self) -> Result<CapeReal,COBIAError> {
		let mut u_bound:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUpperBound.unwrap())((*self.interface).me,&mut u_bound as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(u_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_dimensionality<TypeOfDimensionality:CapeArrayRealProviderOut>(&self,dimensionality:&mut TypeOfDimensionality) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDimensionality.unwrap())((*self.interface).me,(&dimensionality.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,value:CapeReal,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeIntegerParameter
///
///ICapeIntegerParameter interface
///
pub trait ICapeIntegerParameter {
	fn get_value(&mut self) -> Result<CapeInteger,COBIAError>;
	fn set_value(&mut self,value:CapeInteger) -> Result<(),COBIAError>;
	fn get_default_value(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_lower_bound(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_upper_bound(&mut self) -> Result<CapeInteger,COBIAError>;
	fn validate(&mut self,value:CapeInteger,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeIntegerParameterImpl : ICapeIntegerParameter {
	type T: ICapeInterfaceImpl+ICapeIntegerParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeIntegerParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeIntegerParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeIntegerParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeIntegerParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeIntegerParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeIntegerParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value:*mut CapeInteger) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_value() {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameter::GetValue")
		}
	}

	extern "C" fn raw_set_value(me: *mut std::ffi::c_void,value:CapeInteger) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.set_value(value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameter::SetValue")
		}
	}

	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeInteger) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameter::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_lower_bound(me: *mut std::ffi::c_void,l_bound:*mut CapeInteger) -> crate::C::CapeResult {
		if l_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_lower_bound() {
			Ok(_l_bound) => {
				unsafe{*l_bound=_l_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameter::GetLowerBound")
		}
	}

	extern "C" fn raw_get_upper_bound(me: *mut std::ffi::c_void,u_bound:*mut CapeInteger) -> crate::C::CapeResult {
		if u_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_upper_bound() {
			Ok(_u_bound) => {
				unsafe{*u_bound=_u_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameter::GetUpperBound")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:CapeInteger,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameter::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeIntegerParameter_VTable =
		C::CAPEOPEN_1_2_ICapeIntegerParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValue: Some(Self::T::raw_get_value),
			putValue: Some(Self::T::raw_set_value),
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getLowerBound: Some(Self::T::raw_get_lower_bound),
			getUpperBound: Some(Self::T::raw_get_upper_bound),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEINTEGERPARAMETER_UUID)]
pub struct CapeIntegerParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeIntegerParameter,
}

impl CapeIntegerParameter {

	pub fn get_value(&self) -> Result<CapeInteger,COBIAError> {
		let mut value:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValue.unwrap())((*self.interface).me,&mut value as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_value(&self,value:CapeInteger) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putValue.unwrap())((*self.interface).me,value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_default_value(&self) -> Result<CapeInteger,COBIAError> {
		let mut default_value:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_lower_bound(&self) -> Result<CapeInteger,COBIAError> {
		let mut l_bound:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getLowerBound.unwrap())((*self.interface).me,&mut l_bound as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(l_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upper_bound(&self) -> Result<CapeInteger,COBIAError> {
		let mut u_bound:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUpperBound.unwrap())((*self.interface).me,&mut u_bound as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(u_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,value:CapeInteger,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeStringParameter
///
///ICapeStringParameter interface
///
pub trait ICapeStringParameter {
	fn get_value(&mut self,value:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn set_value(&mut self,value:&CapeStringIn) -> Result<(),COBIAError>;
	fn get_default_value(&mut self,default_value:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn get_option_list(&mut self,option_names:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_restricted_to_list(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeStringIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeStringParameterImpl : ICapeStringParameter {
	type T: ICapeInterfaceImpl+ICapeStringParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeStringParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeStringParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeStringParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeStringParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeStringParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeStringParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut value=CapeStringOut::new(&mut value);
		match myself.get_value(&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeStringParameter::GetValue")
		}
	}

	extern "C" fn raw_set_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value=CapeStringIn::new(&value);
		match myself.set_value(&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeStringParameter::SetValue")
		}
	}

	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut default_value=unsafe{*((&default_value as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut default_value=CapeStringOut::new(&mut default_value);
		match myself.get_default_value(&mut default_value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeStringParameter::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_option_list(me: *mut std::ffi::c_void,option_names:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if option_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if option_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut option_names=unsafe{*((&option_names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut option_names=CapeArrayStringOut::new(&mut option_names);
		match myself.get_option_list(&mut option_names) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeStringParameter::GetOptionList")
		}
	}

	extern "C" fn raw_get_restricted_to_list(me: *mut std::ffi::c_void,restricted:*mut CapeBoolean) -> crate::C::CapeResult {
		if restricted.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_restricted_to_list() {
			Ok(_restricted) => {
				unsafe{*restricted=_restricted;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeStringParameter::GetRestrictedToList")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeString,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeStringIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeStringParameter::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeStringParameter_VTable =
		C::CAPEOPEN_1_2_ICapeStringParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValue: Some(Self::T::raw_get_value),
			putValue: Some(Self::T::raw_set_value),
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getOptionList: Some(Self::T::raw_get_option_list),
			getRestrictedToList: Some(Self::T::raw_get_restricted_to_list),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPESTRINGPARAMETER_UUID)]
pub struct CapeStringParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeStringParameter,
}

impl CapeStringParameter {

	pub fn get_value<TypeOfValue:CapeStringProviderOut>(&self,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValue.unwrap())((*self.interface).me,(&value.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_value<TypeOfValue:CapeStringProviderIn>(&self,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putValue.unwrap())((*self.interface).me,(&value.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_default_value<TypeOfDefaultValue:CapeStringProviderOut>(&self,default_value:&mut TypeOfDefaultValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,(&default_value.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_option_list<TypeOfOptionNames:CapeArrayStringProviderOut>(&self,option_names:&mut TypeOfOptionNames) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getOptionList.unwrap())((*self.interface).me,(&option_names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_restricted_to_list(&self) -> Result<CapeBoolean,COBIAError> {
		let mut restricted:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getRestrictedToList.unwrap())((*self.interface).me,&mut restricted as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(restricted)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeStringProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeBooleanParameter
///
///ICapeBooleanParameter interface
///
pub trait ICapeBooleanParameter {
	fn get_value(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn set_value(&mut self,value:CapeBoolean) -> Result<(),COBIAError>;
	fn get_default_value(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:CapeBoolean,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeBooleanParameterImpl : ICapeBooleanParameter {
	type T: ICapeInterfaceImpl+ICapeBooleanParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeBooleanParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeBooleanParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeBooleanParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeBooleanParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeBooleanParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeBooleanParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value:*mut CapeBoolean) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_value() {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeBooleanParameter::GetValue")
		}
	}

	extern "C" fn raw_set_value(me: *mut std::ffi::c_void,value:CapeBoolean) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.set_value(value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeBooleanParameter::SetValue")
		}
	}

	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeBoolean) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeBooleanParameter::GetDefaultValue")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:CapeBoolean,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeBooleanParameter::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeBooleanParameter_VTable =
		C::CAPEOPEN_1_2_ICapeBooleanParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValue: Some(Self::T::raw_get_value),
			putValue: Some(Self::T::raw_set_value),
			getDefaultValue: Some(Self::T::raw_get_default_value),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEBOOLEANPARAMETER_UUID)]
pub struct CapeBooleanParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeBooleanParameter,
}

impl CapeBooleanParameter {

	pub fn get_value(&self) -> Result<CapeBoolean,COBIAError> {
		let mut value:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValue.unwrap())((*self.interface).me,&mut value as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_value(&self,value:CapeBoolean) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putValue.unwrap())((*self.interface).me,value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_default_value(&self) -> Result<CapeBoolean,COBIAError> {
		let mut default_value:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,value:CapeBoolean,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayParameter
///
///ICapeArrayParameter interface
///
pub trait ICapeArrayParameter {
	fn get_num_dimensions(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_size(&mut self,size:&mut CapeArrayIntegerOut) -> Result<(),COBIAError>;
}

pub trait ICapeArrayParameterImpl : ICapeArrayParameter {
	type T: ICapeInterfaceImpl+ICapeArrayParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_num_dimensions(me: *mut std::ffi::c_void,num_dimensions:*mut CapeInteger) -> crate::C::CapeResult {
		if num_dimensions.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_num_dimensions() {
			Ok(_num_dimensions) => {
				unsafe{*num_dimensions=_num_dimensions;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayParameter::GetNumDimensions")
		}
	}

	extern "C" fn raw_get_size(me: *mut std::ffi::c_void,size:*mut crate::C::ICapeArrayInteger) -> crate::C::CapeResult {
		if size.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if size.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut size=unsafe{*((&size as *const *mut crate::C::ICapeArrayInteger) as *mut *mut crate::C::ICapeArrayInteger)};
		let mut size=CapeArrayIntegerOut::new(&mut size);
		match myself.get_size(&mut size) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayParameter::GetSize")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayParameter_VTable =
		C::CAPEOPEN_1_2_ICapeArrayParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getNumDimensions: Some(Self::T::raw_get_num_dimensions),
			getSize: Some(Self::T::raw_get_size),
		};
}

#[cape_smart_pointer(ICAPEARRAYPARAMETER_UUID)]
pub struct CapeArrayParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayParameter,
}

impl CapeArrayParameter {

	pub fn get_num_dimensions(&self) -> Result<CapeInteger,COBIAError> {
		let mut num_dimensions:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getNumDimensions.unwrap())((*self.interface).me,&mut num_dimensions as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(num_dimensions)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_size<TypeOfSize:CapeArrayIntegerProviderOut>(&self,size:&mut TypeOfSize) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getSize.unwrap())((*self.interface).me,(&size.as_cape_array_integer_out() as *const crate::C::ICapeArrayInteger).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayRealParameter
///
///ICapeArrayRealParameter interface
///
pub trait ICapeArrayRealParameter {
	fn get_value(&mut self,value:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn set_value(&mut self,value:&CapeArrayRealIn) -> Result<(),COBIAError>;
	fn get_element_value(&mut self,position:&CapeArrayIntegerIn) -> Result<CapeReal,COBIAError>;
	fn set_element_value(&mut self,position:&CapeArrayIntegerIn,value:CapeReal) -> Result<(),COBIAError>;
	fn get_default_value(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_lower_bound(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_upper_bound(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_dimensionality(&mut self,dimensionality:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn validate_element(&mut self,position:&CapeArrayIntegerIn,value:CapeReal,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeArrayRealIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeArrayRealParameterImpl : ICapeArrayRealParameter {
	type T: ICapeInterfaceImpl+ICapeArrayRealParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayRealParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayRealParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayRealParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayRealParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayRealParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayRealParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut value=CapeArrayRealOut::new(&mut value);
		match myself.get_value(&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::GetValue")
		}
	}

	extern "C" fn raw_set_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value=CapeArrayRealIn::new(&value);
		match myself.set_value(&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::SetValue")
		}
	}

	extern "C" fn raw_get_element_value(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:*mut CapeReal) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let position=CapeArrayIntegerIn::new(&position);
		match myself.get_element_value(&position) {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::GetElementValue")
		}
	}

	extern "C" fn raw_set_element_value(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let position=CapeArrayIntegerIn::new(&position);
		match myself.set_element_value(&position,value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::SetElementValue")
		}
	}

	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeReal) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_lower_bound(me: *mut std::ffi::c_void,l_bound:*mut CapeReal) -> crate::C::CapeResult {
		if l_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_lower_bound() {
			Ok(_l_bound) => {
				unsafe{*l_bound=_l_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::GetLowerBound")
		}
	}

	extern "C" fn raw_get_upper_bound(me: *mut std::ffi::c_void,u_bound:*mut CapeReal) -> crate::C::CapeResult {
		if u_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_upper_bound() {
			Ok(_u_bound) => {
				unsafe{*u_bound=_u_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::GetUpperBound")
		}
	}

	extern "C" fn raw_get_dimensionality(me: *mut std::ffi::c_void,dimensionality:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if dimensionality.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if dimensionality.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut dimensionality=unsafe{*((&dimensionality as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut dimensionality=CapeArrayRealOut::new(&mut dimensionality);
		match myself.get_dimensionality(&mut dimensionality) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::GetDimensionality")
		}
	}

	extern "C" fn raw_validate_element(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeReal,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate_element(&position,value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::ValidateElement")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayReal,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeArrayRealIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameter::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayRealParameter_VTable =
		C::CAPEOPEN_1_2_ICapeArrayRealParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValue: Some(Self::T::raw_get_value),
			putValue: Some(Self::T::raw_set_value),
			GetElementValue: Some(Self::T::raw_get_element_value),
			SetElementValue: Some(Self::T::raw_set_element_value),
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getLowerBound: Some(Self::T::raw_get_lower_bound),
			getUpperBound: Some(Self::T::raw_get_upper_bound),
			getDimensionality: Some(Self::T::raw_get_dimensionality),
			ValidateElement: Some(Self::T::raw_validate_element),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEARRAYREALPARAMETER_UUID)]
pub struct CapeArrayRealParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayRealParameter,
}

impl CapeArrayRealParameter {

	pub fn get_value<TypeOfValue:CapeArrayRealProviderOut>(&self,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValue.unwrap())((*self.interface).me,(&value.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_value<TypeOfValue:CapeArrayRealProviderIn>(&self,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putValue.unwrap())((*self.interface).me,(&value.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_element_value<TypeOfPosition:CapeArrayIntegerProviderIn>(&self,position:&TypeOfPosition) -> Result<CapeReal,COBIAError> {
		let mut value:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetElementValue.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),&mut value as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_element_value<TypeOfPosition:CapeArrayIntegerProviderIn>(&self,position:&TypeOfPosition,value:CapeReal) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetElementValue.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_default_value(&self) -> Result<CapeReal,COBIAError> {
		let mut default_value:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_lower_bound(&self) -> Result<CapeReal,COBIAError> {
		let mut l_bound:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getLowerBound.unwrap())((*self.interface).me,&mut l_bound as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(l_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upper_bound(&self) -> Result<CapeReal,COBIAError> {
		let mut u_bound:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUpperBound.unwrap())((*self.interface).me,&mut u_bound as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(u_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_dimensionality<TypeOfDimensionality:CapeArrayRealProviderOut>(&self,dimensionality:&mut TypeOfDimensionality) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDimensionality.unwrap())((*self.interface).me,(&dimensionality.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate_element<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:CapeReal,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).ValidateElement.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeArrayRealProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayIntegerParameter
///
///ICapeArrayIntegerParameter interface
///
pub trait ICapeArrayIntegerParameter {
	fn get_value(&mut self,value:&mut CapeArrayIntegerOut) -> Result<(),COBIAError>;
	fn set_value(&mut self,value:&CapeArrayIntegerIn) -> Result<(),COBIAError>;
	fn get_element_value(&mut self,position:&CapeArrayIntegerIn) -> Result<CapeInteger,COBIAError>;
	fn set_element_value(&mut self,position:&CapeArrayIntegerIn,value:CapeInteger) -> Result<(),COBIAError>;
	fn get_default_value(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_lower_bound(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_upper_bound(&mut self) -> Result<CapeInteger,COBIAError>;
	fn validate_element(&mut self,position:&CapeArrayIntegerIn,value:CapeInteger,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeArrayIntegerIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeArrayIntegerParameterImpl : ICapeArrayIntegerParameter {
	type T: ICapeInterfaceImpl+ICapeArrayIntegerParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayIntegerParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayIntegerParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayIntegerParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayIntegerParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayIntegerParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayIntegerParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayInteger) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayInteger) as *mut *mut crate::C::ICapeArrayInteger)};
		let mut value=CapeArrayIntegerOut::new(&mut value);
		match myself.get_value(&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::GetValue")
		}
	}

	extern "C" fn raw_set_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayInteger) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value=CapeArrayIntegerIn::new(&value);
		match myself.set_value(&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::SetValue")
		}
	}

	extern "C" fn raw_get_element_value(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:*mut CapeInteger) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let position=CapeArrayIntegerIn::new(&position);
		match myself.get_element_value(&position) {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::GetElementValue")
		}
	}

	extern "C" fn raw_set_element_value(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeInteger) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let position=CapeArrayIntegerIn::new(&position);
		match myself.set_element_value(&position,value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::SetElementValue")
		}
	}

	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeInteger) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_lower_bound(me: *mut std::ffi::c_void,l_bound:*mut CapeInteger) -> crate::C::CapeResult {
		if l_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_lower_bound() {
			Ok(_l_bound) => {
				unsafe{*l_bound=_l_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::GetLowerBound")
		}
	}

	extern "C" fn raw_get_upper_bound(me: *mut std::ffi::c_void,u_bound:*mut CapeInteger) -> crate::C::CapeResult {
		if u_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_upper_bound() {
			Ok(_u_bound) => {
				unsafe{*u_bound=_u_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::GetUpperBound")
		}
	}

	extern "C" fn raw_validate_element(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeInteger,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate_element(&position,value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::ValidateElement")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayInteger,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeArrayIntegerIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameter::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayIntegerParameter_VTable =
		C::CAPEOPEN_1_2_ICapeArrayIntegerParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValue: Some(Self::T::raw_get_value),
			putValue: Some(Self::T::raw_set_value),
			GetElementValue: Some(Self::T::raw_get_element_value),
			SetElementValue: Some(Self::T::raw_set_element_value),
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getLowerBound: Some(Self::T::raw_get_lower_bound),
			getUpperBound: Some(Self::T::raw_get_upper_bound),
			ValidateElement: Some(Self::T::raw_validate_element),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEARRAYINTEGERPARAMETER_UUID)]
pub struct CapeArrayIntegerParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayIntegerParameter,
}

impl CapeArrayIntegerParameter {

	pub fn get_value<TypeOfValue:CapeArrayIntegerProviderOut>(&self,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValue.unwrap())((*self.interface).me,(&value.as_cape_array_integer_out() as *const crate::C::ICapeArrayInteger).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_value<TypeOfValue:CapeArrayIntegerProviderIn>(&self,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putValue.unwrap())((*self.interface).me,(&value.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_element_value<TypeOfPosition:CapeArrayIntegerProviderIn>(&self,position:&TypeOfPosition) -> Result<CapeInteger,COBIAError> {
		let mut value:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetElementValue.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),&mut value as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_element_value<TypeOfPosition:CapeArrayIntegerProviderIn>(&self,position:&TypeOfPosition,value:CapeInteger) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetElementValue.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_default_value(&self) -> Result<CapeInteger,COBIAError> {
		let mut default_value:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_lower_bound(&self) -> Result<CapeInteger,COBIAError> {
		let mut l_bound:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getLowerBound.unwrap())((*self.interface).me,&mut l_bound as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(l_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upper_bound(&self) -> Result<CapeInteger,COBIAError> {
		let mut u_bound:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUpperBound.unwrap())((*self.interface).me,&mut u_bound as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(u_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate_element<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:CapeInteger,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).ValidateElement.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeArrayIntegerProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayStringParameter
///
///ICapeArrayStringParameter interface
///
pub trait ICapeArrayStringParameter {
	fn get_value(&mut self,value:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn set_value(&mut self,value:&CapeArrayStringIn) -> Result<(),COBIAError>;
	fn get_element_value(&mut self,position:&CapeArrayIntegerIn,value:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn set_element_value(&mut self,position:&CapeArrayIntegerIn,value:&CapeStringIn) -> Result<(),COBIAError>;
	fn get_default_value(&mut self,default_value:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn get_option_list(&mut self,option_names:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_restricted_to_list(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn validate_element(&mut self,position:&CapeArrayIntegerIn,value:&CapeStringIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeArrayStringIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeArrayStringParameterImpl : ICapeArrayStringParameter {
	type T: ICapeInterfaceImpl+ICapeArrayStringParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayStringParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayStringParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayStringParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayStringParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayStringParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayStringParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut value=CapeArrayStringOut::new(&mut value);
		match myself.get_value(&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::GetValue")
		}
	}

	extern "C" fn raw_set_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value=CapeArrayStringIn::new(&value);
		match myself.set_value(&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::SetValue")
		}
	}

	extern "C" fn raw_get_element_value(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut value=CapeStringOut::new(&mut value);
		match myself.get_element_value(&position,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::GetElementValue")
		}
	}

	extern "C" fn raw_set_element_value(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let position=CapeArrayIntegerIn::new(&position);
		let value=CapeStringIn::new(&value);
		match myself.set_element_value(&position,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::SetElementValue")
		}
	}

	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut default_value=unsafe{*((&default_value as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut default_value=CapeStringOut::new(&mut default_value);
		match myself.get_default_value(&mut default_value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_option_list(me: *mut std::ffi::c_void,option_names:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if option_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if option_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut option_names=unsafe{*((&option_names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut option_names=CapeArrayStringOut::new(&mut option_names);
		match myself.get_option_list(&mut option_names) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::GetOptionList")
		}
	}

	extern "C" fn raw_get_restricted_to_list(me: *mut std::ffi::c_void,restricted:*mut CapeBoolean) -> crate::C::CapeResult {
		if restricted.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_restricted_to_list() {
			Ok(_restricted) => {
				unsafe{*restricted=_restricted;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::GetRestrictedToList")
		}
	}

	extern "C" fn raw_validate_element(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:*mut crate::C::ICapeString,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let value=CapeStringIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate_element(&position,&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::ValidateElement")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayString,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeArrayStringIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameter::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayStringParameter_VTable =
		C::CAPEOPEN_1_2_ICapeArrayStringParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValue: Some(Self::T::raw_get_value),
			putValue: Some(Self::T::raw_set_value),
			GetElementValue: Some(Self::T::raw_get_element_value),
			SetElementValue: Some(Self::T::raw_set_element_value),
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getOptionList: Some(Self::T::raw_get_option_list),
			getRestrictedToList: Some(Self::T::raw_get_restricted_to_list),
			ValidateElement: Some(Self::T::raw_validate_element),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEARRAYSTRINGPARAMETER_UUID)]
pub struct CapeArrayStringParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayStringParameter,
}

impl CapeArrayStringParameter {

	pub fn get_value<TypeOfValue:CapeArrayStringProviderOut>(&self,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValue.unwrap())((*self.interface).me,(&value.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_value<TypeOfValue:CapeArrayStringProviderIn>(&self,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putValue.unwrap())((*self.interface).me,(&value.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_element_value<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfValue:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetElementValue.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),(&value.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_element_value<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfValue:CapeStringProviderIn>(&self,position:&TypeOfPosition,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetElementValue.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),(&value.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_default_value<TypeOfDefaultValue:CapeStringProviderOut>(&self,default_value:&mut TypeOfDefaultValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,(&default_value.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_option_list<TypeOfOptionNames:CapeArrayStringProviderOut>(&self,option_names:&mut TypeOfOptionNames) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getOptionList.unwrap())((*self.interface).me,(&option_names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_restricted_to_list(&self) -> Result<CapeBoolean,COBIAError> {
		let mut restricted:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getRestrictedToList.unwrap())((*self.interface).me,&mut restricted as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(restricted)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate_element<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfValue:CapeStringProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).ValidateElement.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),(&value.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeArrayStringProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayBooleanParameter
///
///ICapeArrayBooleanParameter interface
///
pub trait ICapeArrayBooleanParameter {
	fn get_value(&mut self,value:&mut CapeArrayBooleanOut) -> Result<(),COBIAError>;
	fn set_value(&mut self,value:&CapeArrayBooleanIn) -> Result<(),COBIAError>;
	fn get_element_value(&mut self,position:&CapeArrayIntegerIn) -> Result<CapeBoolean,COBIAError>;
	fn set_element_value(&mut self,position:&CapeArrayIntegerIn,value:CapeBoolean) -> Result<(),COBIAError>;
	fn get_default_value(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn validate_element(&mut self,position:&CapeArrayIntegerIn,value:CapeBoolean,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeArrayBooleanIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeArrayBooleanParameterImpl : ICapeArrayBooleanParameter {
	type T: ICapeInterfaceImpl+ICapeArrayBooleanParameterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayBooleanParameter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayBooleanParameter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayBooleanParameterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayBooleanParameter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayBooleanParameter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayBooleanParameter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayBoolean) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayBoolean) as *mut *mut crate::C::ICapeArrayBoolean)};
		let mut value=CapeArrayBooleanOut::new(&mut value);
		match myself.get_value(&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameter::GetValue")
		}
	}

	extern "C" fn raw_set_value(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayBoolean) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value=CapeArrayBooleanIn::new(&value);
		match myself.set_value(&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameter::SetValue")
		}
	}

	extern "C" fn raw_get_element_value(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:*mut CapeBoolean) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let position=CapeArrayIntegerIn::new(&position);
		match myself.get_element_value(&position) {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameter::GetElementValue")
		}
	}

	extern "C" fn raw_set_element_value(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeBoolean) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let position=CapeArrayIntegerIn::new(&position);
		match myself.set_element_value(&position,value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameter::SetElementValue")
		}
	}

	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeBoolean) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameter::GetDefaultValue")
		}
	}

	extern "C" fn raw_validate_element(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeBoolean,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate_element(&position,value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameter::ValidateElement")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayBoolean,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeArrayBooleanIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameter::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayBooleanParameter_VTable =
		C::CAPEOPEN_1_2_ICapeArrayBooleanParameter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValue: Some(Self::T::raw_get_value),
			putValue: Some(Self::T::raw_set_value),
			GetElementValue: Some(Self::T::raw_get_element_value),
			SetElementValue: Some(Self::T::raw_set_element_value),
			getDefaultValue: Some(Self::T::raw_get_default_value),
			ValidateElement: Some(Self::T::raw_validate_element),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEARRAYBOOLEANPARAMETER_UUID)]
pub struct CapeArrayBooleanParameter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayBooleanParameter,
}

impl CapeArrayBooleanParameter {

	pub fn get_value<TypeOfValue:CapeArrayBooleanProviderOut>(&self,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValue.unwrap())((*self.interface).me,(&value.as_cape_array_boolean_out() as *const crate::C::ICapeArrayBoolean).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_value<TypeOfValue:CapeArrayBooleanProviderIn>(&self,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putValue.unwrap())((*self.interface).me,(&value.as_cape_array_boolean_in() as *const crate::C::ICapeArrayBoolean).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_element_value<TypeOfPosition:CapeArrayIntegerProviderIn>(&self,position:&TypeOfPosition) -> Result<CapeBoolean,COBIAError> {
		let mut value:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetElementValue.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),&mut value as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_element_value<TypeOfPosition:CapeArrayIntegerProviderIn>(&self,position:&TypeOfPosition,value:CapeBoolean) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetElementValue.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_default_value(&self) -> Result<CapeBoolean,COBIAError> {
		let mut default_value:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate_element<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:CapeBoolean,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).ValidateElement.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeArrayBooleanProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_array_boolean_in() as *const crate::C::ICapeArrayBoolean).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeParameterSpecification
///
///ICapeParameterSpecification interface
///
pub trait ICapeParameterSpecification {
	fn get_type(&mut self) -> Result<CapeParamType,COBIAError>;
}

pub trait ICapeParameterSpecificationImpl : ICapeParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_type(me: *mut std::ffi::c_void,parameter_type:*mut C::CAPEOPEN_1_2_CapeParamType) -> crate::C::CapeResult {
		if parameter_type.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_type() {
			Ok(_parameter_type) => {
				unsafe{*parameter_type=_parameter_type as C::CAPEOPEN_1_2_CapeParamType;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeParameterSpecification::GetType")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getType: Some(Self::T::raw_get_type),
		};
}

#[cape_smart_pointer(ICAPEPARAMETERSPECIFICATION_UUID)]
pub struct CapeParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeParameterSpecification,
}

impl CapeParameterSpecification {

	pub fn get_type(&self) -> Result<CapeParamType,COBIAError> {
		let mut parameter_type:C::CAPEOPEN_1_2_CapeParamType=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getType.unwrap())((*self.interface).me,&mut parameter_type as *mut C::CAPEOPEN_1_2_CapeParamType)
		};
		let parameter_type=match CapeParamType::from(parameter_type) {
			Some(_parameter_type) => _parameter_type,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(parameter_type)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeRealParameterSpecification
///
///ICapeRealParameterSpecification interface
///
pub trait ICapeRealParameterSpecification {
	fn get_default_value(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_lower_bound(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_upper_bound(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_dimensionality(&mut self,dimensionality:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn validate(&mut self,value:CapeReal,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeRealParameterSpecificationImpl : ICapeRealParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeRealParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeRealParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeRealParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeRealParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeRealParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeRealParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeRealParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeReal) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameterSpecification::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_lower_bound(me: *mut std::ffi::c_void,l_bound:*mut CapeReal) -> crate::C::CapeResult {
		if l_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_lower_bound() {
			Ok(_l_bound) => {
				unsafe{*l_bound=_l_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameterSpecification::GetLowerBound")
		}
	}

	extern "C" fn raw_get_upper_bound(me: *mut std::ffi::c_void,u_bound:*mut CapeReal) -> crate::C::CapeResult {
		if u_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_upper_bound() {
			Ok(_u_bound) => {
				unsafe{*u_bound=_u_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameterSpecification::GetUpperBound")
		}
	}

	extern "C" fn raw_get_dimensionality(me: *mut std::ffi::c_void,dimensionality:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if dimensionality.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if dimensionality.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut dimensionality=unsafe{*((&dimensionality as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut dimensionality=CapeArrayRealOut::new(&mut dimensionality);
		match myself.get_dimensionality(&mut dimensionality) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeRealParameterSpecification::GetDimensionality")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:CapeReal,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeRealParameterSpecification::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeRealParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeRealParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getLowerBound: Some(Self::T::raw_get_lower_bound),
			getUpperBound: Some(Self::T::raw_get_upper_bound),
			getDimensionality: Some(Self::T::raw_get_dimensionality),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEREALPARAMETERSPECIFICATION_UUID)]
pub struct CapeRealParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeRealParameterSpecification,
}

impl CapeRealParameterSpecification {

	pub fn get_default_value(&self) -> Result<CapeReal,COBIAError> {
		let mut default_value:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_lower_bound(&self) -> Result<CapeReal,COBIAError> {
		let mut l_bound:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getLowerBound.unwrap())((*self.interface).me,&mut l_bound as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(l_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upper_bound(&self) -> Result<CapeReal,COBIAError> {
		let mut u_bound:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUpperBound.unwrap())((*self.interface).me,&mut u_bound as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(u_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_dimensionality<TypeOfDimensionality:CapeArrayRealProviderOut>(&self,dimensionality:&mut TypeOfDimensionality) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDimensionality.unwrap())((*self.interface).me,(&dimensionality.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,value:CapeReal,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeIntegerParameterSpecification
///
///ICapeIntegerParameterSpecification interface
///
pub trait ICapeIntegerParameterSpecification {
	fn get_default_value(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_lower_bound(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_upper_bound(&mut self) -> Result<CapeInteger,COBIAError>;
	fn validate(&mut self,value:CapeInteger,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeIntegerParameterSpecificationImpl : ICapeIntegerParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeIntegerParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeIntegerParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeIntegerParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeIntegerParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeIntegerParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeIntegerParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeIntegerParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeInteger) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameterSpecification::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_lower_bound(me: *mut std::ffi::c_void,l_bound:*mut CapeInteger) -> crate::C::CapeResult {
		if l_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_lower_bound() {
			Ok(_l_bound) => {
				unsafe{*l_bound=_l_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameterSpecification::GetLowerBound")
		}
	}

	extern "C" fn raw_get_upper_bound(me: *mut std::ffi::c_void,u_bound:*mut CapeInteger) -> crate::C::CapeResult {
		if u_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_upper_bound() {
			Ok(_u_bound) => {
				unsafe{*u_bound=_u_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameterSpecification::GetUpperBound")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:CapeInteger,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeIntegerParameterSpecification::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeIntegerParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeIntegerParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getLowerBound: Some(Self::T::raw_get_lower_bound),
			getUpperBound: Some(Self::T::raw_get_upper_bound),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEINTEGERPARAMETERSPECIFICATION_UUID)]
pub struct CapeIntegerParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeIntegerParameterSpecification,
}

impl CapeIntegerParameterSpecification {

	pub fn get_default_value(&self) -> Result<CapeInteger,COBIAError> {
		let mut default_value:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_lower_bound(&self) -> Result<CapeInteger,COBIAError> {
		let mut l_bound:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getLowerBound.unwrap())((*self.interface).me,&mut l_bound as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(l_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upper_bound(&self) -> Result<CapeInteger,COBIAError> {
		let mut u_bound:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUpperBound.unwrap())((*self.interface).me,&mut u_bound as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(u_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,value:CapeInteger,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeStringParameterSpecification
///
///ICapeStringParameterSpecification interface
///
pub trait ICapeStringParameterSpecification {
	fn get_default_value(&mut self,default_value:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn get_option_list(&mut self,option_names:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_restricted_to_list(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeStringIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeStringParameterSpecificationImpl : ICapeStringParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeStringParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeStringParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeStringParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeStringParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeStringParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeStringParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeStringParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut default_value=unsafe{*((&default_value as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut default_value=CapeStringOut::new(&mut default_value);
		match myself.get_default_value(&mut default_value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeStringParameterSpecification::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_option_list(me: *mut std::ffi::c_void,option_names:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if option_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if option_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut option_names=unsafe{*((&option_names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut option_names=CapeArrayStringOut::new(&mut option_names);
		match myself.get_option_list(&mut option_names) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeStringParameterSpecification::GetOptionList")
		}
	}

	extern "C" fn raw_get_restricted_to_list(me: *mut std::ffi::c_void,restricted:*mut CapeBoolean) -> crate::C::CapeResult {
		if restricted.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_restricted_to_list() {
			Ok(_restricted) => {
				unsafe{*restricted=_restricted;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeStringParameterSpecification::GetRestrictedToList")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeString,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeStringIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeStringParameterSpecification::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeStringParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeStringParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getOptionList: Some(Self::T::raw_get_option_list),
			getRestrictedToList: Some(Self::T::raw_get_restricted_to_list),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPESTRINGPARAMETERSPECIFICATION_UUID)]
pub struct CapeStringParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeStringParameterSpecification,
}

impl CapeStringParameterSpecification {

	pub fn get_default_value<TypeOfDefaultValue:CapeStringProviderOut>(&self,default_value:&mut TypeOfDefaultValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,(&default_value.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_option_list<TypeOfOptionNames:CapeArrayStringProviderOut>(&self,option_names:&mut TypeOfOptionNames) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getOptionList.unwrap())((*self.interface).me,(&option_names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_restricted_to_list(&self) -> Result<CapeBoolean,COBIAError> {
		let mut restricted:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getRestrictedToList.unwrap())((*self.interface).me,&mut restricted as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(restricted)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeStringProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeBooleanParameterSpecification
///
///ICapeBooleanParameterSpecification interface
///
pub trait ICapeBooleanParameterSpecification {
	fn get_default_value(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:CapeBoolean,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeBooleanParameterSpecificationImpl : ICapeBooleanParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeBooleanParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeBooleanParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeBooleanParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeBooleanParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeBooleanParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeBooleanParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeBooleanParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeBoolean) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeBooleanParameterSpecification::GetDefaultValue")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:CapeBoolean,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeBooleanParameterSpecification::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeBooleanParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeBooleanParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getDefaultValue: Some(Self::T::raw_get_default_value),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEBOOLEANPARAMETERSPECIFICATION_UUID)]
pub struct CapeBooleanParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeBooleanParameterSpecification,
}

impl CapeBooleanParameterSpecification {

	pub fn get_default_value(&self) -> Result<CapeBoolean,COBIAError> {
		let mut default_value:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,value:CapeBoolean,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayParameterSpecification
///
///ICapeArrayParameterSpecification interface
///
pub trait ICapeArrayParameterSpecification {
	fn get_num_dimensions(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_size(&mut self,size:&mut CapeArrayIntegerOut) -> Result<(),COBIAError>;
}

pub trait ICapeArrayParameterSpecificationImpl : ICapeArrayParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeArrayParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_num_dimensions(me: *mut std::ffi::c_void,num_dimensions:*mut CapeInteger) -> crate::C::CapeResult {
		if num_dimensions.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_num_dimensions() {
			Ok(_num_dimensions) => {
				unsafe{*num_dimensions=_num_dimensions;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayParameterSpecification::GetNumDimensions")
		}
	}

	extern "C" fn raw_get_size(me: *mut std::ffi::c_void,size:*mut crate::C::ICapeArrayInteger) -> crate::C::CapeResult {
		if size.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if size.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut size=unsafe{*((&size as *const *mut crate::C::ICapeArrayInteger) as *mut *mut crate::C::ICapeArrayInteger)};
		let mut size=CapeArrayIntegerOut::new(&mut size);
		match myself.get_size(&mut size) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayParameterSpecification::GetSize")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeArrayParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getNumDimensions: Some(Self::T::raw_get_num_dimensions),
			getSize: Some(Self::T::raw_get_size),
		};
}

#[cape_smart_pointer(ICAPEARRAYPARAMETERSPECIFICATION_UUID)]
pub struct CapeArrayParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayParameterSpecification,
}

impl CapeArrayParameterSpecification {

	pub fn get_num_dimensions(&self) -> Result<CapeInteger,COBIAError> {
		let mut num_dimensions:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getNumDimensions.unwrap())((*self.interface).me,&mut num_dimensions as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(num_dimensions)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_size<TypeOfSize:CapeArrayIntegerProviderOut>(&self,size:&mut TypeOfSize) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getSize.unwrap())((*self.interface).me,(&size.as_cape_array_integer_out() as *const crate::C::ICapeArrayInteger).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayRealParameterSpecification
///
///ICapeArrayRealParameterSpecification interface
///
pub trait ICapeArrayRealParameterSpecification {
	fn get_default_value(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_lower_bound(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_upper_bound(&mut self) -> Result<CapeReal,COBIAError>;
	fn get_dimensionality(&mut self,dimensionality:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn validate_element(&mut self,position:&CapeArrayIntegerIn,value:CapeReal,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeArrayRealIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeArrayRealParameterSpecificationImpl : ICapeArrayRealParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeArrayRealParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayRealParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayRealParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayRealParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayRealParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayRealParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayRealParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeReal) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameterSpecification::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_lower_bound(me: *mut std::ffi::c_void,l_bound:*mut CapeReal) -> crate::C::CapeResult {
		if l_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_lower_bound() {
			Ok(_l_bound) => {
				unsafe{*l_bound=_l_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameterSpecification::GetLowerBound")
		}
	}

	extern "C" fn raw_get_upper_bound(me: *mut std::ffi::c_void,u_bound:*mut CapeReal) -> crate::C::CapeResult {
		if u_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_upper_bound() {
			Ok(_u_bound) => {
				unsafe{*u_bound=_u_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameterSpecification::GetUpperBound")
		}
	}

	extern "C" fn raw_get_dimensionality(me: *mut std::ffi::c_void,dimensionality:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if dimensionality.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if dimensionality.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut dimensionality=unsafe{*((&dimensionality as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut dimensionality=CapeArrayRealOut::new(&mut dimensionality);
		match myself.get_dimensionality(&mut dimensionality) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameterSpecification::GetDimensionality")
		}
	}

	extern "C" fn raw_validate_element(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeReal,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate_element(&position,value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameterSpecification::ValidateElement")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayReal,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeArrayRealIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayRealParameterSpecification::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayRealParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeArrayRealParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getLowerBound: Some(Self::T::raw_get_lower_bound),
			getUpperBound: Some(Self::T::raw_get_upper_bound),
			getDimensionality: Some(Self::T::raw_get_dimensionality),
			ValidateElement: Some(Self::T::raw_validate_element),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEARRAYREALPARAMETERSPECIFICATION_UUID)]
pub struct CapeArrayRealParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayRealParameterSpecification,
}

impl CapeArrayRealParameterSpecification {

	pub fn get_default_value(&self) -> Result<CapeReal,COBIAError> {
		let mut default_value:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_lower_bound(&self) -> Result<CapeReal,COBIAError> {
		let mut l_bound:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getLowerBound.unwrap())((*self.interface).me,&mut l_bound as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(l_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upper_bound(&self) -> Result<CapeReal,COBIAError> {
		let mut u_bound:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUpperBound.unwrap())((*self.interface).me,&mut u_bound as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(u_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_dimensionality<TypeOfDimensionality:CapeArrayRealProviderOut>(&self,dimensionality:&mut TypeOfDimensionality) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDimensionality.unwrap())((*self.interface).me,(&dimensionality.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate_element<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:CapeReal,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).ValidateElement.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeArrayRealProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayIntegerParameterSpecification
///
///ICapeArrayIntegerParameterSpecification interface
///
pub trait ICapeArrayIntegerParameterSpecification {
	fn get_default_value(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_lower_bound(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_upper_bound(&mut self) -> Result<CapeInteger,COBIAError>;
	fn validate_element(&mut self,position:&CapeArrayIntegerIn,value:CapeInteger,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeArrayIntegerIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeArrayIntegerParameterSpecificationImpl : ICapeArrayIntegerParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeArrayIntegerParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayIntegerParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayIntegerParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayIntegerParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayIntegerParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayIntegerParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayIntegerParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeInteger) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameterSpecification::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_lower_bound(me: *mut std::ffi::c_void,l_bound:*mut CapeInteger) -> crate::C::CapeResult {
		if l_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_lower_bound() {
			Ok(_l_bound) => {
				unsafe{*l_bound=_l_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameterSpecification::GetLowerBound")
		}
	}

	extern "C" fn raw_get_upper_bound(me: *mut std::ffi::c_void,u_bound:*mut CapeInteger) -> crate::C::CapeResult {
		if u_bound.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_upper_bound() {
			Ok(_u_bound) => {
				unsafe{*u_bound=_u_bound;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameterSpecification::GetUpperBound")
		}
	}

	extern "C" fn raw_validate_element(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeInteger,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate_element(&position,value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameterSpecification::ValidateElement")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayInteger,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeArrayIntegerIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayIntegerParameterSpecification::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayIntegerParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeArrayIntegerParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getLowerBound: Some(Self::T::raw_get_lower_bound),
			getUpperBound: Some(Self::T::raw_get_upper_bound),
			ValidateElement: Some(Self::T::raw_validate_element),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEARRAYINTEGERPARAMETERSPECIFICATION_UUID)]
pub struct CapeArrayIntegerParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayIntegerParameterSpecification,
}

impl CapeArrayIntegerParameterSpecification {

	pub fn get_default_value(&self) -> Result<CapeInteger,COBIAError> {
		let mut default_value:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_lower_bound(&self) -> Result<CapeInteger,COBIAError> {
		let mut l_bound:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getLowerBound.unwrap())((*self.interface).me,&mut l_bound as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(l_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upper_bound(&self) -> Result<CapeInteger,COBIAError> {
		let mut u_bound:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUpperBound.unwrap())((*self.interface).me,&mut u_bound as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(u_bound)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate_element<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:CapeInteger,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).ValidateElement.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeArrayIntegerProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayStringParameterSpecification
///
///ICapeArrayStringParameterSpecification interface
///
pub trait ICapeArrayStringParameterSpecification {
	fn get_default_value(&mut self,default_value:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn get_option_list(&mut self,option_names:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_restricted_to_list(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn validate_element(&mut self,position:&CapeArrayIntegerIn,value:&CapeStringIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeArrayStringIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeArrayStringParameterSpecificationImpl : ICapeArrayStringParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeArrayStringParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayStringParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayStringParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayStringParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayStringParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayStringParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayStringParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut default_value=unsafe{*((&default_value as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut default_value=CapeStringOut::new(&mut default_value);
		match myself.get_default_value(&mut default_value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameterSpecification::GetDefaultValue")
		}
	}

	extern "C" fn raw_get_option_list(me: *mut std::ffi::c_void,option_names:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if option_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if option_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut option_names=unsafe{*((&option_names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut option_names=CapeArrayStringOut::new(&mut option_names);
		match myself.get_option_list(&mut option_names) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameterSpecification::GetOptionList")
		}
	}

	extern "C" fn raw_get_restricted_to_list(me: *mut std::ffi::c_void,restricted:*mut CapeBoolean) -> crate::C::CapeResult {
		if restricted.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_restricted_to_list() {
			Ok(_restricted) => {
				unsafe{*restricted=_restricted;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameterSpecification::GetRestrictedToList")
		}
	}

	extern "C" fn raw_validate_element(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:*mut crate::C::ICapeString,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let value=CapeStringIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate_element(&position,&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameterSpecification::ValidateElement")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayString,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeArrayStringIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayStringParameterSpecification::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayStringParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeArrayStringParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getDefaultValue: Some(Self::T::raw_get_default_value),
			getOptionList: Some(Self::T::raw_get_option_list),
			getRestrictedToList: Some(Self::T::raw_get_restricted_to_list),
			ValidateElement: Some(Self::T::raw_validate_element),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEARRAYSTRINGPARAMETERSPECIFICATION_UUID)]
pub struct CapeArrayStringParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayStringParameterSpecification,
}

impl CapeArrayStringParameterSpecification {

	pub fn get_default_value<TypeOfDefaultValue:CapeStringProviderOut>(&self,default_value:&mut TypeOfDefaultValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,(&default_value.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_option_list<TypeOfOptionNames:CapeArrayStringProviderOut>(&self,option_names:&mut TypeOfOptionNames) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getOptionList.unwrap())((*self.interface).me,(&option_names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_restricted_to_list(&self) -> Result<CapeBoolean,COBIAError> {
		let mut restricted:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getRestrictedToList.unwrap())((*self.interface).me,&mut restricted as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(restricted)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate_element<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfValue:CapeStringProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).ValidateElement.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),(&value.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeArrayStringProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeArrayBooleanParameterSpecification
///
///ICapeArrayBooleanParameterSpecification interface
///
pub trait ICapeArrayBooleanParameterSpecification {
	fn get_default_value(&mut self) -> Result<CapeBoolean,COBIAError>;
	fn validate_element(&mut self,position:&CapeArrayIntegerIn,value:CapeBoolean,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn validate(&mut self,value:&CapeArrayBooleanIn,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeArrayBooleanParameterSpecificationImpl : ICapeArrayBooleanParameterSpecification {
	type T: ICapeInterfaceImpl+ICapeArrayBooleanParameterSpecificationImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeArrayBooleanParameterSpecification interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeArrayBooleanParameterSpecification_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeArrayBooleanParameterSpecificationImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeArrayBooleanParameterSpecification =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeArrayBooleanParameterSpecification;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeArrayBooleanParameterSpecification_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_default_value(me: *mut std::ffi::c_void,default_value:*mut CapeBoolean) -> crate::C::CapeResult {
		if default_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_default_value() {
			Ok(_default_value) => {
				unsafe{*default_value=_default_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameterSpecification::GetDefaultValue")
		}
	}

	extern "C" fn raw_validate_element(me: *mut std::ffi::c_void,position:*mut crate::C::ICapeArrayInteger,value:CapeBoolean,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let position=CapeArrayIntegerIn::new(&position);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate_element(&position,value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameterSpecification::ValidateElement")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,value:*mut crate::C::ICapeArrayBoolean,message:*mut crate::C::ICapeString,is_ok:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_ok.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value=CapeArrayBooleanIn::new(&value);
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&value,&mut message) {
			Ok(_is_ok) => {
				unsafe{*is_ok=_is_ok;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeArrayBooleanParameterSpecification::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeArrayBooleanParameterSpecification_VTable =
		C::CAPEOPEN_1_2_ICapeArrayBooleanParameterSpecification_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getDefaultValue: Some(Self::T::raw_get_default_value),
			ValidateElement: Some(Self::T::raw_validate_element),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEARRAYBOOLEANPARAMETERSPECIFICATION_UUID)]
pub struct CapeArrayBooleanParameterSpecification {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeArrayBooleanParameterSpecification,
}

impl CapeArrayBooleanParameterSpecification {

	pub fn get_default_value(&self) -> Result<CapeBoolean,COBIAError> {
		let mut default_value:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDefaultValue.unwrap())((*self.interface).me,&mut default_value as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(default_value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate_element<TypeOfPosition:CapeArrayIntegerProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,position:&TypeOfPosition,value:CapeBoolean,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).ValidateElement.unwrap())((*self.interface).me,(&position.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut(),value,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfValue:CapeArrayBooleanProviderIn,TypeOfMessage:CapeStringProviderOut>(&self,value:&TypeOfValue,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_ok:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&value.as_cape_array_boolean_in() as *const crate::C::ICapeArrayBoolean).cast_mut(),(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_ok as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_ok)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeUtilities
///
///ICapeUtilities interface
///
pub trait ICapeUtilities {
	fn get_parameters(&mut self) -> Result<CapeCollection<CapeParameter>,COBIAError>;
	fn set_simulation_context(&mut self,context:CapeSimulationContext) -> Result<(),COBIAError>;
	fn initialize(&mut self) -> Result<(),COBIAError>;
	fn terminate(&mut self) -> Result<(),COBIAError>;
	fn edit(&mut self,parent:CapeWindowId) -> Result<CapeEditResult,COBIAError>;
}

pub trait ICapeUtilitiesImpl : ICapeUtilities {
	type T: ICapeInterfaceImpl+ICapeUtilitiesImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeUtilities interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeUtilities_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeUtilitiesImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeUtilities =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeUtilities;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeUtilities_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_parameters(me: *mut std::ffi::c_void,parameters:*mut *mut C::CAPEOPEN_1_2_ICapeCollection) -> crate::C::CapeResult {
		if parameters.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if parameters.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		match myself.get_parameters() {
			Ok(_parameters) => {
				unsafe{*parameters=_parameters.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeUtilities::GetParameters")
		}
	}

	extern "C" fn raw_set_simulation_context(me: *mut std::ffi::c_void,context:*mut C::CAPEOPEN_1_2_ICapeSimulationContext) -> crate::C::CapeResult {
		if context.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if context.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let context=CapeSimulationContext::from_interface_pointer(context);
		match myself.set_simulation_context(context) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeUtilities::SetSimulationContext")
		}
	}

	extern "C" fn raw_initialize(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.initialize() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeUtilities::Initialize")
		}
	}

	extern "C" fn raw_terminate(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.terminate() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeUtilities::Terminate")
		}
	}

	extern "C" fn raw_edit(me: *mut std::ffi::c_void,parent:crate::C::CapeWindowId,result:*mut C::CAPEOPEN_1_2_CapeEditResult) -> crate::C::CapeResult {
		if result.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.edit(crate::CapeWindowIdFromRaw(parent)) {
			Ok(_result) => {
				unsafe{*result=_result as C::CAPEOPEN_1_2_CapeEditResult;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeUtilities::Edit")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeUtilities_VTable =
		C::CAPEOPEN_1_2_ICapeUtilities_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getParameters: Some(Self::T::raw_get_parameters),
			putSimulationContext: Some(Self::T::raw_set_simulation_context),
			Initialize: Some(Self::T::raw_initialize),
			Terminate: Some(Self::T::raw_terminate),
			Edit: Some(Self::T::raw_edit),
		};
}

#[cape_smart_pointer(ICAPEUTILITIES_UUID)]
pub struct CapeUtilities {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeUtilities,
}

impl CapeUtilities {

	pub fn get_parameters(&self) -> Result<CapeCollection<CapeParameter>,COBIAError> {
		let mut parameters: *mut C::CAPEOPEN_1_2_ICapeCollection=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).getParameters.unwrap())((*self.interface).me,&mut parameters as *mut *mut C::CAPEOPEN_1_2_ICapeCollection)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(CapeCollection::<CapeParameter>::attach(parameters))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_simulation_context(&self,context:&CapeSimulationContext) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).putSimulationContext.unwrap())((*self.interface).me,context.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeSimulationContext)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn initialize(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Initialize.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn terminate(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Terminate.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn edit(&self,parent:CapeWindowId) -> Result<CapeEditResult,COBIAError> {
		let mut result:C::CAPEOPEN_1_2_CapeEditResult=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Edit.unwrap())((*self.interface).me,crate::CapeWindowIdToRaw(parent),&mut result as *mut C::CAPEOPEN_1_2_CapeEditResult)
		};
		let result=match CapeEditResult::from(result) {
			Some(_result) => _result,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(result)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeSimulationContext
///
///ICapeSimulationContext interface
///
pub trait ICapeSimulationContext {
}

pub trait ICapeSimulationContextImpl : ICapeSimulationContext {
	type T: ICapeInterfaceImpl+ICapeSimulationContextImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeSimulationContext interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeSimulationContext_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeSimulationContextImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeSimulationContext =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeSimulationContext;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeSimulationContext_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	const VTABLE: C::CAPEOPEN_1_2_ICapeSimulationContext_VTable =
		C::CAPEOPEN_1_2_ICapeSimulationContext_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
		};
}

#[cape_smart_pointer(ICAPESIMULATIONCONTEXT_UUID)]
pub struct CapeSimulationContext {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeSimulationContext,
}

impl CapeSimulationContext {

}

///ICapeDiagnostic
///
///ICapeDiagnostic interface
///
pub trait ICapeDiagnostic {
	fn pop_up_message(&mut self,message:&CapeStringIn) -> Result<(),COBIAError>;
	fn log_message(&mut self,message:&CapeStringIn) -> Result<(),COBIAError>;
}

pub trait ICapeDiagnosticImpl : ICapeDiagnostic {
	type T: ICapeInterfaceImpl+ICapeDiagnosticImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeDiagnostic interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeDiagnostic_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeDiagnosticImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeDiagnostic =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeDiagnostic;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeDiagnostic_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_pop_up_message(me: *mut std::ffi::c_void,message:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let message=CapeStringIn::new(&message);
		match myself.pop_up_message(&message) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeDiagnostic::PopUpMessage")
		}
	}

	extern "C" fn raw_log_message(me: *mut std::ffi::c_void,message:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let message=CapeStringIn::new(&message);
		match myself.log_message(&message) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeDiagnostic::LogMessage")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeDiagnostic_VTable =
		C::CAPEOPEN_1_2_ICapeDiagnostic_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			PopUpMessage: Some(Self::T::raw_pop_up_message),
			LogMessage: Some(Self::T::raw_log_message),
		};
}

#[cape_smart_pointer(ICAPEDIAGNOSTIC_UUID)]
pub struct CapeDiagnostic {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeDiagnostic,
}

impl CapeDiagnostic {

	pub fn pop_up_message<TypeOfMessage:CapeStringProviderIn>(&self,message:&TypeOfMessage) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).PopUpMessage.unwrap())((*self.interface).me,(&message.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn log_message<TypeOfMessage:CapeStringProviderIn>(&self,message:&TypeOfMessage) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).LogMessage.unwrap())((*self.interface).me,(&message.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeMaterialManager
///
///ICapeMaterialManager interface
///
pub trait ICapeMaterialManager {
	fn get_material_list(&mut self,material_name_list:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn create_material(&mut self,material_name:&CapeStringIn) -> Result<crate::CapeObject,COBIAError>;
}

pub trait ICapeMaterialManagerImpl : ICapeMaterialManager {
	type T: ICapeInterfaceImpl+ICapeMaterialManagerImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeMaterialManager interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeMaterialManager_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeMaterialManagerImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeMaterialManager =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeMaterialManager;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeMaterialManager_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_material_list(me: *mut std::ffi::c_void,material_name_list:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if material_name_list.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if material_name_list.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut material_name_list=unsafe{*((&material_name_list as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut material_name_list=CapeArrayStringOut::new(&mut material_name_list);
		match myself.get_material_list(&mut material_name_list) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeMaterialManager::GetMaterialList")
		}
	}

	extern "C" fn raw_create_material(me: *mut std::ffi::c_void,material_name:*mut crate::C::ICapeString,material:*mut *mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if material.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if material.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let material_name=CapeStringIn::new(&material_name);
		match myself.create_material(&material_name) {
			Ok(_material) => {
				unsafe{*material=_material.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeMaterialManager::CreateMaterial")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeMaterialManager_VTable =
		C::CAPEOPEN_1_2_ICapeMaterialManager_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getMaterialList: Some(Self::T::raw_get_material_list),
			CreateMaterial: Some(Self::T::raw_create_material),
		};
}

#[cape_smart_pointer(ICAPEMATERIALMANAGER_UUID)]
pub struct CapeMaterialManager {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeMaterialManager,
}

impl CapeMaterialManager {

	pub fn get_material_list<TypeOfMaterialNameList:CapeArrayStringProviderOut>(&self,material_name_list:&mut TypeOfMaterialNameList) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getMaterialList.unwrap())((*self.interface).me,(&material_name_list.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn create_material<TypeOfMaterialName:CapeStringProviderIn>(&self,material_name:&TypeOfMaterialName) -> Result<crate::CapeObject,COBIAError> {
		let mut material: *mut crate::C::ICapeInterface=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).CreateMaterial.unwrap())((*self.interface).me,(&material_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut material as *mut *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(crate::CapeObject::attach(material))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeCOSEUtilities
///
///ICapeCOSEUtilities interface
///
pub trait ICapeCOSEUtilities {
	fn get_named_value_list(&mut self,named_values:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn named_value(&mut self,name:&CapeStringIn,named_value:&mut CapeValueOut) -> Result<(),COBIAError>;
}

pub trait ICapeCOSEUtilitiesImpl : ICapeCOSEUtilities {
	type T: ICapeInterfaceImpl+ICapeCOSEUtilitiesImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeCOSEUtilities interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeCOSEUtilities_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeCOSEUtilitiesImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeCOSEUtilities =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeCOSEUtilities;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeCOSEUtilities_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_named_value_list(me: *mut std::ffi::c_void,named_values:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if named_values.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if named_values.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut named_values=unsafe{*((&named_values as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut named_values=CapeArrayStringOut::new(&mut named_values);
		match myself.get_named_value_list(&mut named_values) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeCOSEUtilities::GetNamedValueList")
		}
	}

	extern "C" fn raw_named_value(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString,named_value:*mut crate::C::ICapeValue) -> crate::C::CapeResult {
		if named_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if named_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let name=CapeStringIn::new(&name);
		let mut named_value=unsafe{*((&named_value as *const *mut crate::C::ICapeValue) as *mut *mut crate::C::ICapeValue)};
		let mut named_value=CapeValueOut::new(&mut named_value);
		match myself.named_value(&name,&mut named_value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeCOSEUtilities::NamedValue")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeCOSEUtilities_VTable =
		C::CAPEOPEN_1_2_ICapeCOSEUtilities_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getNamedValueList: Some(Self::T::raw_get_named_value_list),
			NamedValue: Some(Self::T::raw_named_value),
		};
}

#[cape_smart_pointer(ICAPECOSEUTILITIES_UUID)]
pub struct CapeCOSEUtilities {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeCOSEUtilities,
}

impl CapeCOSEUtilities {

	pub fn get_named_value_list<TypeOfNamedValues:CapeArrayStringProviderOut>(&self,named_values:&mut TypeOfNamedValues) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getNamedValueList.unwrap())((*self.interface).me,(&named_values.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn named_value<TypeOfName:CapeStringProviderIn,TypeOfNamedValue:CapeValueProviderOut>(&self,name:&TypeOfName,named_value:&mut TypeOfNamedValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).NamedValue.unwrap())((*self.interface).me,(&name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&named_value.as_cape_value_out() as *const crate::C::ICapeValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoMaterial
///
///ICapeThermoMaterial interface
///
pub trait ICapeThermoMaterial {
	fn clear_all_props(&mut self) -> Result<(),COBIAError>;
	fn copy_from_material(&mut self,source:CapeThermoMaterial) -> Result<(),COBIAError>;
	fn create_material(&mut self) -> Result<CapeThermoMaterial,COBIAError>;
	fn get_overall_prop(&mut self,property:&CapeStringIn,basis:&CapeStringIn,results:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn get_overall_tpfraction(&mut self,temperature:&mut CapeReal,pressure:&mut CapeReal,composition:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn get_present_phases(&mut self,phase_labels:&mut CapeArrayStringOut,phase_status:&mut CapeArrayEnumerationOut<CapePhaseStatus>) -> Result<(),COBIAError>;
	fn get_single_phase_prop(&mut self,property:&CapeStringIn,phase_label:&CapeStringIn,basis:&CapeStringIn,results:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn get_tpfraction(&mut self,phase_label:&CapeStringIn,temperature:&mut CapeReal,pressure:&mut CapeReal,composition:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn get_two_phase_prop(&mut self,property:&CapeStringIn,phase_labels:&CapeArrayStringIn,basis:&CapeStringIn,results:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn set_overall_prop(&mut self,property:&CapeStringIn,basis:&CapeStringIn,values:&CapeArrayRealIn) -> Result<(),COBIAError>;
	fn set_present_phases(&mut self,phase_labels:&CapeArrayStringIn,phase_status:&CapeArrayEnumerationIn<CapePhaseStatus>) -> Result<(),COBIAError>;
	fn set_single_phase_prop(&mut self,property:&CapeStringIn,phase_label:&CapeStringIn,basis:&CapeStringIn,values:&CapeArrayRealIn) -> Result<(),COBIAError>;
	fn set_two_phase_prop(&mut self,property:&CapeStringIn,phase_labels:&CapeArrayStringIn,basis:&CapeStringIn,values:&CapeArrayRealIn) -> Result<(),COBIAError>;
}

pub trait ICapeThermoMaterialImpl : ICapeThermoMaterial {
	type T: ICapeInterfaceImpl+ICapeThermoMaterialImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoMaterial interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoMaterial_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoMaterialImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoMaterial =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoMaterial;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoMaterial_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_clear_all_props(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.clear_all_props() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::ClearAllProps")
		}
	}

	extern "C" fn raw_copy_from_material(me: *mut std::ffi::c_void,source:*mut C::CAPEOPEN_1_2_ICapeThermoMaterial) -> crate::C::CapeResult {
		if source.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if source.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let source=CapeThermoMaterial::from_interface_pointer(source);
		match myself.copy_from_material(source) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::CopyFromMaterial")
		}
	}

	extern "C" fn raw_create_material(me: *mut std::ffi::c_void,material_object:*mut *mut C::CAPEOPEN_1_2_ICapeThermoMaterial) -> crate::C::CapeResult {
		if material_object.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if material_object.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		match myself.create_material() {
			Ok(_material_object) => {
				unsafe{*material_object=_material_object.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::CreateMaterial")
		}
	}

	extern "C" fn raw_get_overall_prop(me: *mut std::ffi::c_void,property:*mut crate::C::ICapeString,basis:*mut crate::C::ICapeString,results:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if results.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if results.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let property=CapeStringIn::new(&property);
		let basis=CapeStringIn::new(&basis);
		let mut results=unsafe{*((&results as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut results=CapeArrayRealOut::new(&mut results);
		match myself.get_overall_prop(&property,&basis,&mut results) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::GetOverallProp")
		}
	}

	extern "C" fn raw_get_overall_t_p_fraction(me: *mut std::ffi::c_void,temperature:*mut CapeReal,pressure:*mut CapeReal,composition:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if temperature.is_null()||pressure.is_null()||composition.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if composition.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut _temperature:CapeReal=0.0;
		let mut _pressure:CapeReal=0.0;
		let mut composition=unsafe{*((&composition as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut composition=CapeArrayRealOut::new(&mut composition);
		match myself.get_overall_tpfraction(&mut _temperature,&mut _pressure,&mut composition) {
			Ok(_) => {
				unsafe{*temperature=_temperature;}
				unsafe{*pressure=_pressure;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::GetOverallTPFraction")
		}
	}

	extern "C" fn raw_get_present_phases(me: *mut std::ffi::c_void,phase_labels:*mut crate::C::ICapeArrayString,phase_status:*mut crate::C::ICapeArrayEnumeration) -> crate::C::CapeResult {
		if phase_labels.is_null()||phase_status.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if phase_labels.is_null()||phase_status.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut phase_labels=unsafe{*((&phase_labels as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut phase_labels=CapeArrayStringOut::new(&mut phase_labels);
		let mut phase_status=unsafe{*((&phase_status as *const *mut crate::C::ICapeArrayEnumeration) as *mut *mut crate::C::ICapeArrayEnumeration)};
		let mut phase_status=CapeArrayEnumerationOut::<CapePhaseStatus>::new(&mut phase_status);
		match myself.get_present_phases(&mut phase_labels,&mut phase_status) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::GetPresentPhases")
		}
	}

	extern "C" fn raw_get_single_phase_prop(me: *mut std::ffi::c_void,property:*mut crate::C::ICapeString,phase_label:*mut crate::C::ICapeString,basis:*mut crate::C::ICapeString,results:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if results.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if results.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let property=CapeStringIn::new(&property);
		let phase_label=CapeStringIn::new(&phase_label);
		let basis=CapeStringIn::new(&basis);
		let mut results=unsafe{*((&results as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut results=CapeArrayRealOut::new(&mut results);
		match myself.get_single_phase_prop(&property,&phase_label,&basis,&mut results) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::GetSinglePhaseProp")
		}
	}

	extern "C" fn raw_get_t_p_fraction(me: *mut std::ffi::c_void,phase_label:*mut crate::C::ICapeString,temperature:*mut CapeReal,pressure:*mut CapeReal,composition:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if temperature.is_null()||pressure.is_null()||composition.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if composition.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let phase_label=CapeStringIn::new(&phase_label);
		let mut _temperature:CapeReal=0.0;
		let mut _pressure:CapeReal=0.0;
		let mut composition=unsafe{*((&composition as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut composition=CapeArrayRealOut::new(&mut composition);
		match myself.get_tpfraction(&phase_label,&mut _temperature,&mut _pressure,&mut composition) {
			Ok(_) => {
				unsafe{*temperature=_temperature;}
				unsafe{*pressure=_pressure;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::GetTPFraction")
		}
	}

	extern "C" fn raw_get_two_phase_prop(me: *mut std::ffi::c_void,property:*mut crate::C::ICapeString,phase_labels:*mut crate::C::ICapeArrayString,basis:*mut crate::C::ICapeString,results:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if results.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if results.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let property=CapeStringIn::new(&property);
		let phase_labels=CapeArrayStringIn::new(&phase_labels);
		let basis=CapeStringIn::new(&basis);
		let mut results=unsafe{*((&results as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut results=CapeArrayRealOut::new(&mut results);
		match myself.get_two_phase_prop(&property,&phase_labels,&basis,&mut results) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::GetTwoPhaseProp")
		}
	}

	extern "C" fn raw_set_overall_prop(me: *mut std::ffi::c_void,property:*mut crate::C::ICapeString,basis:*mut crate::C::ICapeString,values:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let property=CapeStringIn::new(&property);
		let basis=CapeStringIn::new(&basis);
		let values=CapeArrayRealIn::new(&values);
		match myself.set_overall_prop(&property,&basis,&values) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::SetOverallProp")
		}
	}

	extern "C" fn raw_set_present_phases(me: *mut std::ffi::c_void,phase_labels:*mut crate::C::ICapeArrayString,phase_status:*mut crate::C::ICapeArrayEnumeration) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let phase_labels=CapeArrayStringIn::new(&phase_labels);
		let phase_status=CapeArrayEnumerationIn::<CapePhaseStatus>::new(&phase_status);
		match myself.set_present_phases(&phase_labels,&phase_status) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::SetPresentPhases")
		}
	}

	extern "C" fn raw_set_single_phase_prop(me: *mut std::ffi::c_void,property:*mut crate::C::ICapeString,phase_label:*mut crate::C::ICapeString,basis:*mut crate::C::ICapeString,values:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let property=CapeStringIn::new(&property);
		let phase_label=CapeStringIn::new(&phase_label);
		let basis=CapeStringIn::new(&basis);
		let values=CapeArrayRealIn::new(&values);
		match myself.set_single_phase_prop(&property,&phase_label,&basis,&values) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::SetSinglePhaseProp")
		}
	}

	extern "C" fn raw_set_two_phase_prop(me: *mut std::ffi::c_void,property:*mut crate::C::ICapeString,phase_labels:*mut crate::C::ICapeArrayString,basis:*mut crate::C::ICapeString,values:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let property=CapeStringIn::new(&property);
		let phase_labels=CapeArrayStringIn::new(&phase_labels);
		let basis=CapeStringIn::new(&basis);
		let values=CapeArrayRealIn::new(&values);
		match myself.set_two_phase_prop(&property,&phase_labels,&basis,&values) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterial::SetTwoPhaseProp")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoMaterial_VTable =
		C::CAPEOPEN_1_2_ICapeThermoMaterial_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			ClearAllProps: Some(Self::T::raw_clear_all_props),
			CopyFromMaterial: Some(Self::T::raw_copy_from_material),
			CreateMaterial: Some(Self::T::raw_create_material),
			GetOverallProp: Some(Self::T::raw_get_overall_prop),
			GetOverallTPFraction: Some(Self::T::raw_get_overall_t_p_fraction),
			GetPresentPhases: Some(Self::T::raw_get_present_phases),
			GetSinglePhaseProp: Some(Self::T::raw_get_single_phase_prop),
			GetTPFraction: Some(Self::T::raw_get_t_p_fraction),
			GetTwoPhaseProp: Some(Self::T::raw_get_two_phase_prop),
			SetOverallProp: Some(Self::T::raw_set_overall_prop),
			SetPresentPhases: Some(Self::T::raw_set_present_phases),
			SetSinglePhaseProp: Some(Self::T::raw_set_single_phase_prop),
			SetTwoPhaseProp: Some(Self::T::raw_set_two_phase_prop),
		};
}

#[cape_smart_pointer(ICAPETHERMOMATERIAL_UUID)]
pub struct CapeThermoMaterial {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoMaterial,
}

impl CapeThermoMaterial {

	pub fn clear_all_props(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).ClearAllProps.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn copy_from_material(&self,source:&CapeThermoMaterial) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).CopyFromMaterial.unwrap())((*self.interface).me,source.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoMaterial)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn create_material(&self) -> Result<CapeThermoMaterial,COBIAError> {
		let mut material_object: *mut C::CAPEOPEN_1_2_ICapeThermoMaterial=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).CreateMaterial.unwrap())((*self.interface).me,&mut material_object as *mut *mut C::CAPEOPEN_1_2_ICapeThermoMaterial)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(CapeThermoMaterial::attach(material_object))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_overall_prop<TypeOfProperty:CapeStringProviderIn,TypeOfBasis:CapeStringProviderIn,TypeOfResults:CapeArrayRealProviderOut>(&self,property:&TypeOfProperty,basis:&TypeOfBasis,results:&mut TypeOfResults) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetOverallProp.unwrap())((*self.interface).me,(&property.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&results.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_overall_tpfraction<TypeOfComposition:CapeArrayRealProviderOut>(&self,temperature:&mut CapeReal,pressure:&mut CapeReal,composition:&mut TypeOfComposition) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetOverallTPFraction.unwrap())((*self.interface).me,temperature as *mut CapeReal,pressure as *mut CapeReal,(&composition.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_present_phases<TypeOfPhaseLabels:CapeArrayStringProviderOut,TypeOfPhaseStatus:CapeArrayEnumerationProviderOut>(&self,phase_labels:&mut TypeOfPhaseLabels,phase_status:&mut TypeOfPhaseStatus) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetPresentPhases.unwrap())((*self.interface).me,(&phase_labels.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut(),(&phase_status.as_cape_array_enumeration_out() as *const crate::C::ICapeArrayEnumeration).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_single_phase_prop<TypeOfProperty:CapeStringProviderIn,TypeOfPhaseLabel:CapeStringProviderIn,TypeOfBasis:CapeStringProviderIn,TypeOfResults:CapeArrayRealProviderOut>(&self,property:&TypeOfProperty,phase_label:&TypeOfPhaseLabel,basis:&TypeOfBasis,results:&mut TypeOfResults) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetSinglePhaseProp.unwrap())((*self.interface).me,(&property.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&phase_label.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&results.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_tpfraction<TypeOfPhaseLabel:CapeStringProviderIn,TypeOfComposition:CapeArrayRealProviderOut>(&self,phase_label:&TypeOfPhaseLabel,temperature:&mut CapeReal,pressure:&mut CapeReal,composition:&mut TypeOfComposition) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetTPFraction.unwrap())((*self.interface).me,(&phase_label.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),temperature as *mut CapeReal,pressure as *mut CapeReal,(&composition.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_two_phase_prop<TypeOfProperty:CapeStringProviderIn,TypeOfPhaseLabels:CapeArrayStringProviderIn,TypeOfBasis:CapeStringProviderIn,TypeOfResults:CapeArrayRealProviderOut>(&self,property:&TypeOfProperty,phase_labels:&TypeOfPhaseLabels,basis:&TypeOfBasis,results:&mut TypeOfResults) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetTwoPhaseProp.unwrap())((*self.interface).me,(&property.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&phase_labels.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&results.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_overall_prop<TypeOfProperty:CapeStringProviderIn,TypeOfBasis:CapeStringProviderIn,TypeOfValues:CapeArrayRealProviderIn>(&self,property:&TypeOfProperty,basis:&TypeOfBasis,values:&TypeOfValues) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetOverallProp.unwrap())((*self.interface).me,(&property.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&values.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_present_phases<TypeOfPhaseLabels:CapeArrayStringProviderIn,TypeOfPhaseStatus:CapeArrayEnumerationProviderIn>(&self,phase_labels:&TypeOfPhaseLabels,phase_status:&TypeOfPhaseStatus) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetPresentPhases.unwrap())((*self.interface).me,(&phase_labels.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&phase_status.as_cape_array_enumeration_in() as *const crate::C::ICapeArrayEnumeration).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_single_phase_prop<TypeOfProperty:CapeStringProviderIn,TypeOfPhaseLabel:CapeStringProviderIn,TypeOfBasis:CapeStringProviderIn,TypeOfValues:CapeArrayRealProviderIn>(&self,property:&TypeOfProperty,phase_label:&TypeOfPhaseLabel,basis:&TypeOfBasis,values:&TypeOfValues) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetSinglePhaseProp.unwrap())((*self.interface).me,(&property.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&phase_label.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&values.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_two_phase_prop<TypeOfProperty:CapeStringProviderIn,TypeOfPhaseLabels:CapeArrayStringProviderIn,TypeOfBasis:CapeStringProviderIn,TypeOfValues:CapeArrayRealProviderIn>(&self,property:&TypeOfProperty,phase_labels:&TypeOfPhaseLabels,basis:&TypeOfBasis,values:&TypeOfValues) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetTwoPhaseProp.unwrap())((*self.interface).me,(&property.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&phase_labels.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&values.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoMaterialContext
///
///ICapeThermoMaterialContext interface
///
pub trait ICapeThermoMaterialContext {
	fn set_material(&mut self,material:CapeThermoMaterial) -> Result<(),COBIAError>;
	fn unset_material(&mut self) -> Result<(),COBIAError>;
}

pub trait ICapeThermoMaterialContextImpl : ICapeThermoMaterialContext {
	type T: ICapeInterfaceImpl+ICapeThermoMaterialContextImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoMaterialContext interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoMaterialContext_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoMaterialContextImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoMaterialContext =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoMaterialContext;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoMaterialContext_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_set_material(me: *mut std::ffi::c_void,material:*mut C::CAPEOPEN_1_2_ICapeThermoMaterial) -> crate::C::CapeResult {
		if material.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if material.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let material=CapeThermoMaterial::from_interface_pointer(material);
		match myself.set_material(material) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterialContext::SetMaterial")
		}
	}

	extern "C" fn raw_unset_material(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.unset_material() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterialContext::UnsetMaterial")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoMaterialContext_VTable =
		C::CAPEOPEN_1_2_ICapeThermoMaterialContext_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			SetMaterial: Some(Self::T::raw_set_material),
			UnsetMaterial: Some(Self::T::raw_unset_material),
		};
}

#[cape_smart_pointer(ICAPETHERMOMATERIALCONTEXT_UUID)]
pub struct CapeThermoMaterialContext {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoMaterialContext,
}

impl CapeThermoMaterialContext {

	pub fn set_material(&self,material:&CapeThermoMaterial) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetMaterial.unwrap())((*self.interface).me,material.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoMaterial)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn unset_material(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).UnsetMaterial.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoCompounds
///
///ICapeThermoCompounds interface
///
pub trait ICapeThermoCompounds {
	fn get_compound_constant(&mut self,props:&CapeArrayStringIn,comp_ids:&CapeArrayStringIn,contains_missing_values:&mut CapeBoolean,prop_vals:&mut CapeArrayValueOut) -> Result<(),COBIAError>;
	fn get_compound_list(&mut self,comp_ids:&mut CapeArrayStringOut,formulae:&mut CapeArrayStringOut,names:&mut CapeArrayStringOut,boil_temps:&mut CapeArrayRealOut,molwts:&mut CapeArrayRealOut,casnos:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_const_prop_list(&mut self,props:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_num_compounds(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_pdependent_property(&mut self,props:&CapeArrayStringIn,pressure:CapeReal,comp_ids:&CapeArrayStringIn,contains_missing_values:&mut CapeBoolean,prop_vals:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn get_pdependent_prop_list(&mut self,props:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_tdependent_property(&mut self,props:&CapeArrayStringIn,temperature:CapeReal,comp_ids:&CapeArrayStringIn,contains_missing_values:&mut CapeBoolean,prop_vals:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn get_tdependent_prop_list(&mut self,props:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
}

pub trait ICapeThermoCompoundsImpl : ICapeThermoCompounds {
	type T: ICapeInterfaceImpl+ICapeThermoCompoundsImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoCompounds interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoCompounds_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoCompoundsImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoCompounds =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoCompounds;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoCompounds_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_compound_constant(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString,comp_ids:*mut crate::C::ICapeArrayString,contains_missing_values:*mut CapeBoolean,prop_vals:*mut crate::C::ICapeArrayValue) -> crate::C::CapeResult {
		if contains_missing_values.is_null()||prop_vals.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if prop_vals.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let props=CapeArrayStringIn::new(&props);
		let comp_ids=CapeArrayStringIn::new(&comp_ids);
		let mut _contains_missing_values:CapeBoolean=false as CapeBoolean;
		let mut prop_vals=unsafe{*((&prop_vals as *const *mut crate::C::ICapeArrayValue) as *mut *mut crate::C::ICapeArrayValue)};
		let mut prop_vals=CapeArrayValueOut::new(&mut prop_vals);
		match myself.get_compound_constant(&props,&comp_ids,&mut _contains_missing_values,&mut prop_vals) {
			Ok(_) => {
				unsafe{*contains_missing_values=_contains_missing_values;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoCompounds::GetCompoundConstant")
		}
	}

	extern "C" fn raw_get_compound_list(me: *mut std::ffi::c_void,comp_ids:*mut crate::C::ICapeArrayString,formulae:*mut crate::C::ICapeArrayString,names:*mut crate::C::ICapeArrayString,boil_temps:*mut crate::C::ICapeArrayReal,molwts:*mut crate::C::ICapeArrayReal,casnos:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if comp_ids.is_null()||formulae.is_null()||names.is_null()||boil_temps.is_null()||molwts.is_null()||casnos.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if comp_ids.is_null()||formulae.is_null()||names.is_null()||boil_temps.is_null()||molwts.is_null()||casnos.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut comp_ids=unsafe{*((&comp_ids as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut comp_ids=CapeArrayStringOut::new(&mut comp_ids);
		let mut formulae=unsafe{*((&formulae as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut formulae=CapeArrayStringOut::new(&mut formulae);
		let mut names=unsafe{*((&names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut names=CapeArrayStringOut::new(&mut names);
		let mut boil_temps=unsafe{*((&boil_temps as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut boil_temps=CapeArrayRealOut::new(&mut boil_temps);
		let mut molwts=unsafe{*((&molwts as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut molwts=CapeArrayRealOut::new(&mut molwts);
		let mut casnos=unsafe{*((&casnos as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut casnos=CapeArrayStringOut::new(&mut casnos);
		match myself.get_compound_list(&mut comp_ids,&mut formulae,&mut names,&mut boil_temps,&mut molwts,&mut casnos) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoCompounds::GetCompoundList")
		}
	}

	extern "C" fn raw_get_const_prop_list(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut props=unsafe{*((&props as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut props=CapeArrayStringOut::new(&mut props);
		match myself.get_const_prop_list(&mut props) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoCompounds::GetConstPropList")
		}
	}

	extern "C" fn raw_get_num_compounds(me: *mut std::ffi::c_void,num:*mut CapeInteger) -> crate::C::CapeResult {
		if num.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_num_compounds() {
			Ok(_num) => {
				unsafe{*num=_num;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoCompounds::GetNumCompounds")
		}
	}

	extern "C" fn raw_get_p_dependent_property(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString,pressure:CapeReal,comp_ids:*mut crate::C::ICapeArrayString,contains_missing_values:*mut CapeBoolean,prop_vals:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if contains_missing_values.is_null()||prop_vals.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if prop_vals.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let props=CapeArrayStringIn::new(&props);
		let comp_ids=CapeArrayStringIn::new(&comp_ids);
		let mut _contains_missing_values:CapeBoolean=false as CapeBoolean;
		let mut prop_vals=unsafe{*((&prop_vals as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut prop_vals=CapeArrayRealOut::new(&mut prop_vals);
		match myself.get_pdependent_property(&props,pressure,&comp_ids,&mut _contains_missing_values,&mut prop_vals) {
			Ok(_) => {
				unsafe{*contains_missing_values=_contains_missing_values;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoCompounds::GetPDependentProperty")
		}
	}

	extern "C" fn raw_get_p_dependent_prop_list(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut props=unsafe{*((&props as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut props=CapeArrayStringOut::new(&mut props);
		match myself.get_pdependent_prop_list(&mut props) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoCompounds::GetPDependentPropList")
		}
	}

	extern "C" fn raw_get_t_dependent_property(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString,temperature:CapeReal,comp_ids:*mut crate::C::ICapeArrayString,contains_missing_values:*mut CapeBoolean,prop_vals:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if contains_missing_values.is_null()||prop_vals.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if prop_vals.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let props=CapeArrayStringIn::new(&props);
		let comp_ids=CapeArrayStringIn::new(&comp_ids);
		let mut _contains_missing_values:CapeBoolean=false as CapeBoolean;
		let mut prop_vals=unsafe{*((&prop_vals as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut prop_vals=CapeArrayRealOut::new(&mut prop_vals);
		match myself.get_tdependent_property(&props,temperature,&comp_ids,&mut _contains_missing_values,&mut prop_vals) {
			Ok(_) => {
				unsafe{*contains_missing_values=_contains_missing_values;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoCompounds::GetTDependentProperty")
		}
	}

	extern "C" fn raw_get_t_dependent_prop_list(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut props=unsafe{*((&props as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut props=CapeArrayStringOut::new(&mut props);
		match myself.get_tdependent_prop_list(&mut props) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoCompounds::GetTDependentPropList")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoCompounds_VTable =
		C::CAPEOPEN_1_2_ICapeThermoCompounds_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			GetCompoundConstant: Some(Self::T::raw_get_compound_constant),
			GetCompoundList: Some(Self::T::raw_get_compound_list),
			getConstPropList: Some(Self::T::raw_get_const_prop_list),
			getNumCompounds: Some(Self::T::raw_get_num_compounds),
			GetPDependentProperty: Some(Self::T::raw_get_p_dependent_property),
			getPDependentPropList: Some(Self::T::raw_get_p_dependent_prop_list),
			GetTDependentProperty: Some(Self::T::raw_get_t_dependent_property),
			getTDependentPropList: Some(Self::T::raw_get_t_dependent_prop_list),
		};
}

#[cape_smart_pointer(ICAPETHERMOCOMPOUNDS_UUID)]
pub struct CapeThermoCompounds {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoCompounds,
}

impl CapeThermoCompounds {

	pub fn get_compound_constant<TypeOfProps:CapeArrayStringProviderIn,TypeOfCompIds:CapeArrayStringProviderIn,TypeOfPropVals:CapeArrayValueProviderOut>(&self,props:&TypeOfProps,comp_ids:&TypeOfCompIds,contains_missing_values:&mut CapeBoolean,prop_vals:&mut TypeOfPropVals) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetCompoundConstant.unwrap())((*self.interface).me,(&props.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&comp_ids.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),contains_missing_values as *mut CapeBoolean,(&prop_vals.as_cape_array_value_out() as *const crate::C::ICapeArrayValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_compound_list<TypeOfCompIds:CapeArrayStringProviderOut,TypeOfFormulae:CapeArrayStringProviderOut,TypeOfNames:CapeArrayStringProviderOut,TypeOfBoilTemps:CapeArrayRealProviderOut,TypeOfMolwts:CapeArrayRealProviderOut,TypeOfCasnos:CapeArrayStringProviderOut>(&self,comp_ids:&mut TypeOfCompIds,formulae:&mut TypeOfFormulae,names:&mut TypeOfNames,boil_temps:&mut TypeOfBoilTemps,molwts:&mut TypeOfMolwts,casnos:&mut TypeOfCasnos) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetCompoundList.unwrap())((*self.interface).me,(&comp_ids.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut(),(&formulae.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut(),(&names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut(),(&boil_temps.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut(),(&molwts.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut(),(&casnos.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_const_prop_list<TypeOfProps:CapeArrayStringProviderOut>(&self,props:&mut TypeOfProps) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getConstPropList.unwrap())((*self.interface).me,(&props.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_num_compounds(&self) -> Result<CapeInteger,COBIAError> {
		let mut num:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getNumCompounds.unwrap())((*self.interface).me,&mut num as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(num)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_pdependent_property<TypeOfProps:CapeArrayStringProviderIn,TypeOfCompIds:CapeArrayStringProviderIn,TypeOfPropVals:CapeArrayRealProviderOut>(&self,props:&TypeOfProps,pressure:CapeReal,comp_ids:&TypeOfCompIds,contains_missing_values:&mut CapeBoolean,prop_vals:&mut TypeOfPropVals) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetPDependentProperty.unwrap())((*self.interface).me,(&props.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),pressure,(&comp_ids.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),contains_missing_values as *mut CapeBoolean,(&prop_vals.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_pdependent_prop_list<TypeOfProps:CapeArrayStringProviderOut>(&self,props:&mut TypeOfProps) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getPDependentPropList.unwrap())((*self.interface).me,(&props.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_tdependent_property<TypeOfProps:CapeArrayStringProviderIn,TypeOfCompIds:CapeArrayStringProviderIn,TypeOfPropVals:CapeArrayRealProviderOut>(&self,props:&TypeOfProps,temperature:CapeReal,comp_ids:&TypeOfCompIds,contains_missing_values:&mut CapeBoolean,prop_vals:&mut TypeOfPropVals) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetTDependentProperty.unwrap())((*self.interface).me,(&props.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),temperature,(&comp_ids.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),contains_missing_values as *mut CapeBoolean,(&prop_vals.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_tdependent_prop_list<TypeOfProps:CapeArrayStringProviderOut>(&self,props:&mut TypeOfProps) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getTDependentPropList.unwrap())((*self.interface).me,(&props.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoPhases
///
///ICapeThermoPhases interface
///
pub trait ICapeThermoPhases {
	fn get_num_phases(&mut self) -> Result<CapeInteger,COBIAError>;
	fn get_phase_info(&mut self,phase_label:&CapeStringIn,phase_attribute:&CapeStringIn,value:&mut CapeValueOut) -> Result<(),COBIAError>;
	fn get_phase_list(&mut self,phase_labels:&mut CapeArrayStringOut,state_of_aggregation:&mut CapeArrayStringOut,key_compound_id:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
}

pub trait ICapeThermoPhasesImpl : ICapeThermoPhases {
	type T: ICapeInterfaceImpl+ICapeThermoPhasesImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoPhases interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoPhases_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoPhasesImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoPhases =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoPhases;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoPhases_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_num_phases(me: *mut std::ffi::c_void,num:*mut CapeInteger) -> crate::C::CapeResult {
		if num.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_num_phases() {
			Ok(_num) => {
				unsafe{*num=_num;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoPhases::GetNumPhases")
		}
	}

	extern "C" fn raw_get_phase_info(me: *mut std::ffi::c_void,phase_label:*mut crate::C::ICapeString,phase_attribute:*mut crate::C::ICapeString,value:*mut crate::C::ICapeValue) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let phase_label=CapeStringIn::new(&phase_label);
		let phase_attribute=CapeStringIn::new(&phase_attribute);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeValue) as *mut *mut crate::C::ICapeValue)};
		let mut value=CapeValueOut::new(&mut value);
		match myself.get_phase_info(&phase_label,&phase_attribute,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPhases::GetPhaseInfo")
		}
	}

	extern "C" fn raw_get_phase_list(me: *mut std::ffi::c_void,phase_labels:*mut crate::C::ICapeArrayString,state_of_aggregation:*mut crate::C::ICapeArrayString,key_compound_id:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if phase_labels.is_null()||state_of_aggregation.is_null()||key_compound_id.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if phase_labels.is_null()||state_of_aggregation.is_null()||key_compound_id.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut phase_labels=unsafe{*((&phase_labels as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut phase_labels=CapeArrayStringOut::new(&mut phase_labels);
		let mut state_of_aggregation=unsafe{*((&state_of_aggregation as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut state_of_aggregation=CapeArrayStringOut::new(&mut state_of_aggregation);
		let mut key_compound_id=unsafe{*((&key_compound_id as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut key_compound_id=CapeArrayStringOut::new(&mut key_compound_id);
		match myself.get_phase_list(&mut phase_labels,&mut state_of_aggregation,&mut key_compound_id) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPhases::GetPhaseList")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoPhases_VTable =
		C::CAPEOPEN_1_2_ICapeThermoPhases_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getNumPhases: Some(Self::T::raw_get_num_phases),
			GetPhaseInfo: Some(Self::T::raw_get_phase_info),
			GetPhaseList: Some(Self::T::raw_get_phase_list),
		};
}

#[cape_smart_pointer(ICAPETHERMOPHASES_UUID)]
pub struct CapeThermoPhases {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoPhases,
}

impl CapeThermoPhases {

	pub fn get_num_phases(&self) -> Result<CapeInteger,COBIAError> {
		let mut num:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getNumPhases.unwrap())((*self.interface).me,&mut num as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(num)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_phase_info<TypeOfPhaseLabel:CapeStringProviderIn,TypeOfPhaseAttribute:CapeStringProviderIn,TypeOfValue:CapeValueProviderOut>(&self,phase_label:&TypeOfPhaseLabel,phase_attribute:&TypeOfPhaseAttribute,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetPhaseInfo.unwrap())((*self.interface).me,(&phase_label.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&phase_attribute.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_value_out() as *const crate::C::ICapeValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_phase_list<TypeOfPhaseLabels:CapeArrayStringProviderOut,TypeOfStateOfAggregation:CapeArrayStringProviderOut,TypeOfKeyCompoundId:CapeArrayStringProviderOut>(&self,phase_labels:&mut TypeOfPhaseLabels,state_of_aggregation:&mut TypeOfStateOfAggregation,key_compound_id:&mut TypeOfKeyCompoundId) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetPhaseList.unwrap())((*self.interface).me,(&phase_labels.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut(),(&state_of_aggregation.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut(),(&key_compound_id.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoPropertyRoutine
///
///ICapeThermoPropertyRoutine interface
///
pub trait ICapeThermoPropertyRoutine {
	fn calc_and_get_ln_phi(&mut self,phase_label:&CapeStringIn,temperature:CapeReal,pressure:CapeReal,mole_fraction:&CapeArrayRealIn,f_flags:CapeInteger,ln_phi:&mut CapeArrayRealOut,ln_phi_dt:&mut CapeArrayRealOut,ln_phi_dp:&mut CapeArrayRealOut,ln_phi_dn:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn calc_single_phase_prop(&mut self,props:&CapeArrayStringIn,phase_label:&CapeStringIn) -> Result<(),COBIAError>;
	fn calc_two_phase_prop(&mut self,props:&CapeArrayStringIn,phase_labels:&CapeArrayStringIn) -> Result<(),COBIAError>;
	fn check_single_phase_prop_spec(&mut self,property:&CapeStringIn,phase_label:&CapeStringIn) -> Result<CapeBoolean,COBIAError>;
	fn check_two_phase_prop_spec(&mut self,property:&CapeStringIn,phase_labels:&CapeArrayStringIn) -> Result<CapeBoolean,COBIAError>;
	fn get_single_phase_prop_list(&mut self,props:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_two_phase_prop_list(&mut self,props:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
}

pub trait ICapeThermoPropertyRoutineImpl : ICapeThermoPropertyRoutine {
	type T: ICapeInterfaceImpl+ICapeThermoPropertyRoutineImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoPropertyRoutine interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoPropertyRoutine_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoPropertyRoutineImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoPropertyRoutine =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoPropertyRoutine;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoPropertyRoutine_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_calc_and_get_ln_phi(me: *mut std::ffi::c_void,phase_label:*mut crate::C::ICapeString,temperature:CapeReal,pressure:CapeReal,mole_fraction:*mut crate::C::ICapeArrayReal,f_flags:CapeInteger,ln_phi:*mut crate::C::ICapeArrayReal,ln_phi_dt:*mut crate::C::ICapeArrayReal,ln_phi_dp:*mut crate::C::ICapeArrayReal,ln_phi_dn:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if ln_phi.is_null()||ln_phi_dt.is_null()||ln_phi_dp.is_null()||ln_phi_dn.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if ln_phi.is_null()||ln_phi_dt.is_null()||ln_phi_dp.is_null()||ln_phi_dn.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let phase_label=CapeStringIn::new(&phase_label);
		let mole_fraction=CapeArrayRealIn::new(&mole_fraction);
		let mut ln_phi=unsafe{*((&ln_phi as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut ln_phi=CapeArrayRealOut::new(&mut ln_phi);
		let mut ln_phi_dt=unsafe{*((&ln_phi_dt as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut ln_phi_dt=CapeArrayRealOut::new(&mut ln_phi_dt);
		let mut ln_phi_dp=unsafe{*((&ln_phi_dp as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut ln_phi_dp=CapeArrayRealOut::new(&mut ln_phi_dp);
		let mut ln_phi_dn=unsafe{*((&ln_phi_dn as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut ln_phi_dn=CapeArrayRealOut::new(&mut ln_phi_dn);
		match myself.calc_and_get_ln_phi(&phase_label,temperature,pressure,&mole_fraction,f_flags,&mut ln_phi,&mut ln_phi_dt,&mut ln_phi_dp,&mut ln_phi_dn) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyRoutine::CalcAndGetLnPhi")
		}
	}

	extern "C" fn raw_calc_single_phase_prop(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString,phase_label:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let props=CapeArrayStringIn::new(&props);
		let phase_label=CapeStringIn::new(&phase_label);
		match myself.calc_single_phase_prop(&props,&phase_label) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyRoutine::CalcSinglePhaseProp")
		}
	}

	extern "C" fn raw_calc_two_phase_prop(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString,phase_labels:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let props=CapeArrayStringIn::new(&props);
		let phase_labels=CapeArrayStringIn::new(&phase_labels);
		match myself.calc_two_phase_prop(&props,&phase_labels) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyRoutine::CalcTwoPhaseProp")
		}
	}

	extern "C" fn raw_check_single_phase_prop_spec(me: *mut std::ffi::c_void,property:*mut crate::C::ICapeString,phase_label:*mut crate::C::ICapeString,valid:*mut CapeBoolean) -> crate::C::CapeResult {
		if valid.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let property=CapeStringIn::new(&property);
		let phase_label=CapeStringIn::new(&phase_label);
		match myself.check_single_phase_prop_spec(&property,&phase_label) {
			Ok(_valid) => {
				unsafe{*valid=_valid;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyRoutine::CheckSinglePhasePropSpec")
		}
	}

	extern "C" fn raw_check_two_phase_prop_spec(me: *mut std::ffi::c_void,property:*mut crate::C::ICapeString,phase_labels:*mut crate::C::ICapeArrayString,valid:*mut CapeBoolean) -> crate::C::CapeResult {
		if valid.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let property=CapeStringIn::new(&property);
		let phase_labels=CapeArrayStringIn::new(&phase_labels);
		match myself.check_two_phase_prop_spec(&property,&phase_labels) {
			Ok(_valid) => {
				unsafe{*valid=_valid;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyRoutine::CheckTwoPhasePropSpec")
		}
	}

	extern "C" fn raw_get_single_phase_prop_list(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut props=unsafe{*((&props as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut props=CapeArrayStringOut::new(&mut props);
		match myself.get_single_phase_prop_list(&mut props) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyRoutine::GetSinglePhasePropList")
		}
	}

	extern "C" fn raw_get_two_phase_prop_list(me: *mut std::ffi::c_void,props:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if props.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut props=unsafe{*((&props as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut props=CapeArrayStringOut::new(&mut props);
		match myself.get_two_phase_prop_list(&mut props) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyRoutine::GetTwoPhasePropList")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoPropertyRoutine_VTable =
		C::CAPEOPEN_1_2_ICapeThermoPropertyRoutine_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			CalcAndGetLnPhi: Some(Self::T::raw_calc_and_get_ln_phi),
			CalcSinglePhaseProp: Some(Self::T::raw_calc_single_phase_prop),
			CalcTwoPhaseProp: Some(Self::T::raw_calc_two_phase_prop),
			CheckSinglePhasePropSpec: Some(Self::T::raw_check_single_phase_prop_spec),
			CheckTwoPhasePropSpec: Some(Self::T::raw_check_two_phase_prop_spec),
			getSinglePhasePropList: Some(Self::T::raw_get_single_phase_prop_list),
			getTwoPhasePropList: Some(Self::T::raw_get_two_phase_prop_list),
		};
}

#[cape_smart_pointer(ICAPETHERMOPROPERTYROUTINE_UUID)]
pub struct CapeThermoPropertyRoutine {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoPropertyRoutine,
}

impl CapeThermoPropertyRoutine {

	pub fn calc_and_get_ln_phi<TypeOfPhaseLabel:CapeStringProviderIn,TypeOfMoleFraction:CapeArrayRealProviderIn,TypeOfLnPhi:CapeArrayRealProviderOut,TypeOfLnPhiDt:CapeArrayRealProviderOut,TypeOfLnPhiDp:CapeArrayRealProviderOut,TypeOfLnPhiDn:CapeArrayRealProviderOut>(&self,phase_label:&TypeOfPhaseLabel,temperature:CapeReal,pressure:CapeReal,mole_fraction:&TypeOfMoleFraction,f_flags:CapeInteger,ln_phi:&mut TypeOfLnPhi,ln_phi_dt:&mut TypeOfLnPhiDt,ln_phi_dp:&mut TypeOfLnPhiDp,ln_phi_dn:&mut TypeOfLnPhiDn) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).CalcAndGetLnPhi.unwrap())((*self.interface).me,(&phase_label.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),temperature,pressure,(&mole_fraction.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut(),f_flags,(&ln_phi.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut(),(&ln_phi_dt.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut(),(&ln_phi_dp.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut(),(&ln_phi_dn.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn calc_single_phase_prop<TypeOfProps:CapeArrayStringProviderIn,TypeOfPhaseLabel:CapeStringProviderIn>(&self,props:&TypeOfProps,phase_label:&TypeOfPhaseLabel) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).CalcSinglePhaseProp.unwrap())((*self.interface).me,(&props.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&phase_label.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn calc_two_phase_prop<TypeOfProps:CapeArrayStringProviderIn,TypeOfPhaseLabels:CapeArrayStringProviderIn>(&self,props:&TypeOfProps,phase_labels:&TypeOfPhaseLabels) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).CalcTwoPhaseProp.unwrap())((*self.interface).me,(&props.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&phase_labels.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn check_single_phase_prop_spec<TypeOfProperty:CapeStringProviderIn,TypeOfPhaseLabel:CapeStringProviderIn>(&self,property:&TypeOfProperty,phase_label:&TypeOfPhaseLabel) -> Result<CapeBoolean,COBIAError> {
		let mut valid:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).CheckSinglePhasePropSpec.unwrap())((*self.interface).me,(&property.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&phase_label.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut valid as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(valid)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn check_two_phase_prop_spec<TypeOfProperty:CapeStringProviderIn,TypeOfPhaseLabels:CapeArrayStringProviderIn>(&self,property:&TypeOfProperty,phase_labels:&TypeOfPhaseLabels) -> Result<CapeBoolean,COBIAError> {
		let mut valid:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).CheckTwoPhasePropSpec.unwrap())((*self.interface).me,(&property.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&phase_labels.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),&mut valid as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(valid)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_single_phase_prop_list<TypeOfProps:CapeArrayStringProviderOut>(&self,props:&mut TypeOfProps) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getSinglePhasePropList.unwrap())((*self.interface).me,(&props.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_two_phase_prop_list<TypeOfProps:CapeArrayStringProviderOut>(&self,props:&mut TypeOfProps) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getTwoPhasePropList.unwrap())((*self.interface).me,(&props.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoEquilibriumRoutine
///
///ICapeThermoEquilibriumRoutine interface
///
pub trait ICapeThermoEquilibriumRoutine {
	fn calc_equilibrium(&mut self,specification1:&CapeArrayStringIn,specification2:&CapeArrayStringIn,solution_type:&CapeStringIn) -> Result<(),COBIAError>;
	fn check_equilibrium_spec(&mut self,specification1:&CapeArrayStringIn,specification2:&CapeArrayStringIn,solution_type:&CapeStringIn) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeThermoEquilibriumRoutineImpl : ICapeThermoEquilibriumRoutine {
	type T: ICapeInterfaceImpl+ICapeThermoEquilibriumRoutineImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoEquilibriumRoutine interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoEquilibriumRoutine_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoEquilibriumRoutineImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoEquilibriumRoutine =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoEquilibriumRoutine;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoEquilibriumRoutine_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_calc_equilibrium(me: *mut std::ffi::c_void,specification1:*mut crate::C::ICapeArrayString,specification2:*mut crate::C::ICapeArrayString,solution_type:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let specification1=CapeArrayStringIn::new(&specification1);
		let specification2=CapeArrayStringIn::new(&specification2);
		let solution_type=CapeStringIn::new(&solution_type);
		match myself.calc_equilibrium(&specification1,&specification2,&solution_type) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoEquilibriumRoutine::CalcEquilibrium")
		}
	}

	extern "C" fn raw_check_equilibrium_spec(me: *mut std::ffi::c_void,specification1:*mut crate::C::ICapeArrayString,specification2:*mut crate::C::ICapeArrayString,solution_type:*mut crate::C::ICapeString,is_supported:*mut CapeBoolean) -> crate::C::CapeResult {
		if is_supported.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let specification1=CapeArrayStringIn::new(&specification1);
		let specification2=CapeArrayStringIn::new(&specification2);
		let solution_type=CapeStringIn::new(&solution_type);
		match myself.check_equilibrium_spec(&specification1,&specification2,&solution_type) {
			Ok(_is_supported) => {
				unsafe{*is_supported=_is_supported;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoEquilibriumRoutine::CheckEquilibriumSpec")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoEquilibriumRoutine_VTable =
		C::CAPEOPEN_1_2_ICapeThermoEquilibriumRoutine_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			CalcEquilibrium: Some(Self::T::raw_calc_equilibrium),
			CheckEquilibriumSpec: Some(Self::T::raw_check_equilibrium_spec),
		};
}

#[cape_smart_pointer(ICAPETHERMOEQUILIBRIUMROUTINE_UUID)]
pub struct CapeThermoEquilibriumRoutine {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoEquilibriumRoutine,
}

impl CapeThermoEquilibriumRoutine {

	pub fn calc_equilibrium<TypeOfSpecification1:CapeArrayStringProviderIn,TypeOfSpecification2:CapeArrayStringProviderIn,TypeOfSolutionType:CapeStringProviderIn>(&self,specification1:&TypeOfSpecification1,specification2:&TypeOfSpecification2,solution_type:&TypeOfSolutionType) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).CalcEquilibrium.unwrap())((*self.interface).me,(&specification1.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&specification2.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&solution_type.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn check_equilibrium_spec<TypeOfSpecification1:CapeArrayStringProviderIn,TypeOfSpecification2:CapeArrayStringProviderIn,TypeOfSolutionType:CapeStringProviderIn>(&self,specification1:&TypeOfSpecification1,specification2:&TypeOfSpecification2,solution_type:&TypeOfSolutionType) -> Result<CapeBoolean,COBIAError> {
		let mut is_supported:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).CheckEquilibriumSpec.unwrap())((*self.interface).me,(&specification1.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&specification2.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut(),(&solution_type.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut is_supported as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_supported)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoUniversalConstant
///
///ICapeThermoUniversalConstant interface
///
pub trait ICapeThermoUniversalConstant {
	fn get_universal_constant(&mut self,constant_id:&CapeStringIn,constant_value:&mut CapeValueOut) -> Result<(),COBIAError>;
	fn get_universal_constant_list(&mut self,constant_id_list:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
}

pub trait ICapeThermoUniversalConstantImpl : ICapeThermoUniversalConstant {
	type T: ICapeInterfaceImpl+ICapeThermoUniversalConstantImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoUniversalConstant interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoUniversalConstant_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoUniversalConstantImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoUniversalConstant =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoUniversalConstant;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoUniversalConstant_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_universal_constant(me: *mut std::ffi::c_void,constant_id:*mut crate::C::ICapeString,constant_value:*mut crate::C::ICapeValue) -> crate::C::CapeResult {
		if constant_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if constant_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let constant_id=CapeStringIn::new(&constant_id);
		let mut constant_value=unsafe{*((&constant_value as *const *mut crate::C::ICapeValue) as *mut *mut crate::C::ICapeValue)};
		let mut constant_value=CapeValueOut::new(&mut constant_value);
		match myself.get_universal_constant(&constant_id,&mut constant_value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoUniversalConstant::GetUniversalConstant")
		}
	}

	extern "C" fn raw_get_universal_constant_list(me: *mut std::ffi::c_void,constant_id_list:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if constant_id_list.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if constant_id_list.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut constant_id_list=unsafe{*((&constant_id_list as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut constant_id_list=CapeArrayStringOut::new(&mut constant_id_list);
		match myself.get_universal_constant_list(&mut constant_id_list) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoUniversalConstant::GetUniversalConstantList")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoUniversalConstant_VTable =
		C::CAPEOPEN_1_2_ICapeThermoUniversalConstant_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			GetUniversalConstant: Some(Self::T::raw_get_universal_constant),
			getUniversalConstantList: Some(Self::T::raw_get_universal_constant_list),
		};
}

#[cape_smart_pointer(ICAPETHERMOUNIVERSALCONSTANT_UUID)]
pub struct CapeThermoUniversalConstant {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoUniversalConstant,
}

impl CapeThermoUniversalConstant {

	pub fn get_universal_constant<TypeOfConstantId:CapeStringProviderIn,TypeOfConstantValue:CapeValueProviderOut>(&self,constant_id:&TypeOfConstantId,constant_value:&mut TypeOfConstantValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetUniversalConstant.unwrap())((*self.interface).me,(&constant_id.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&constant_value.as_cape_value_out() as *const crate::C::ICapeValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_universal_constant_list<TypeOfConstantIdList:CapeArrayStringProviderOut>(&self,constant_id_list:&mut TypeOfConstantIdList) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getUniversalConstantList.unwrap())((*self.interface).me,(&constant_id_list.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoPropertyPackageManager
///
///ICapeThermoPropertyPackageManager interface
///
pub trait ICapeThermoPropertyPackageManager {
	fn get_property_package_list(&mut self,package_names:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_property_package(&mut self,package_name:&CapeStringIn) -> Result<crate::CapeObject,COBIAError>;
}

pub trait ICapeThermoPropertyPackageManagerImpl : ICapeThermoPropertyPackageManager {
	type T: ICapeInterfaceImpl+ICapeThermoPropertyPackageManagerImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoPropertyPackageManager interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoPropertyPackageManager_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoPropertyPackageManagerImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoPropertyPackageManager =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoPropertyPackageManager;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoPropertyPackageManager_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_property_package_list(me: *mut std::ffi::c_void,package_names:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if package_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if package_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut package_names=unsafe{*((&package_names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut package_names=CapeArrayStringOut::new(&mut package_names);
		match myself.get_property_package_list(&mut package_names) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyPackageManager::GetPropertyPackageList")
		}
	}

	extern "C" fn raw_get_property_package(me: *mut std::ffi::c_void,package_name:*mut crate::C::ICapeString,package:*mut *mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if package.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if package.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let package_name=CapeStringIn::new(&package_name);
		match myself.get_property_package(&package_name) {
			Ok(_package) => {
				unsafe{*package=_package.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoPropertyPackageManager::GetPropertyPackage")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoPropertyPackageManager_VTable =
		C::CAPEOPEN_1_2_ICapeThermoPropertyPackageManager_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getPropertyPackageList: Some(Self::T::raw_get_property_package_list),
			GetPropertyPackage: Some(Self::T::raw_get_property_package),
		};
}

#[cape_smart_pointer(ICAPETHERMOPROPERTYPACKAGEMANAGER_UUID)]
pub struct CapeThermoPropertyPackageManager {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoPropertyPackageManager,
}

impl CapeThermoPropertyPackageManager {

	pub fn get_property_package_list<TypeOfPackageNames:CapeArrayStringProviderOut>(&self,package_names:&mut TypeOfPackageNames) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getPropertyPackageList.unwrap())((*self.interface).me,(&package_names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_property_package<TypeOfPackageName:CapeStringProviderIn>(&self,package_name:&TypeOfPackageName) -> Result<crate::CapeObject,COBIAError> {
		let mut package: *mut crate::C::ICapeInterface=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetPropertyPackage.unwrap())((*self.interface).me,(&package_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut package as *mut *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(crate::CapeObject::attach(package))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeUnit
///
///ICapeUnit interface
///
pub trait ICapeUnit {
	fn ports(&mut self) -> Result<CapeCollection<CapeUnitPort>,COBIAError>;
	fn get_val_status(&mut self) -> Result<CapeValidationStatus,COBIAError>;
	fn calculate(&mut self) -> Result<(),COBIAError>;
	fn validate(&mut self,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapeUnitImpl : ICapeUnit {
	type T: ICapeInterfaceImpl+ICapeUnitImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeUnit interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeUnit_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeUnitImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeUnit =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeUnit;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeUnit_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_ports(me: *mut std::ffi::c_void,ports:*mut *mut C::CAPEOPEN_1_2_ICapeCollection) -> crate::C::CapeResult {
		if ports.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if ports.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		match myself.ports() {
			Ok(_ports) => {
				unsafe{*ports=_ports.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeUnit::ports")
		}
	}

	extern "C" fn raw_get_val_status(me: *mut std::ffi::c_void,val_status:*mut C::CAPEOPEN_1_2_CapeValidationStatus) -> crate::C::CapeResult {
		if val_status.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_val_status() {
			Ok(_val_status) => {
				unsafe{*val_status=_val_status as C::CAPEOPEN_1_2_CapeValidationStatus;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeUnit::GetValStatus")
		}
	}

	extern "C" fn raw_calculate(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.calculate() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeUnit::Calculate")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,message:*mut crate::C::ICapeString,is_valid:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_valid.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&mut message) {
			Ok(_is_valid) => {
				unsafe{*is_valid=_is_valid;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeUnit::Validate")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeUnit_VTable =
		C::CAPEOPEN_1_2_ICapeUnit_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			ports: Some(Self::T::raw_ports),
			getValStatus: Some(Self::T::raw_get_val_status),
			Calculate: Some(Self::T::raw_calculate),
			Validate: Some(Self::T::raw_validate),
		};
}

#[cape_smart_pointer(ICAPEUNIT_UUID)]
pub struct CapeUnit {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeUnit,
}

impl CapeUnit {

	pub fn ports(&self) -> Result<CapeCollection<CapeUnitPort>,COBIAError> {
		let mut ports: *mut C::CAPEOPEN_1_2_ICapeCollection=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).ports.unwrap())((*self.interface).me,&mut ports as *mut *mut C::CAPEOPEN_1_2_ICapeCollection)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(CapeCollection::<CapeUnitPort>::attach(ports))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_val_status(&self) -> Result<CapeValidationStatus,COBIAError> {
		let mut val_status:C::CAPEOPEN_1_2_CapeValidationStatus=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValStatus.unwrap())((*self.interface).me,&mut val_status as *mut C::CAPEOPEN_1_2_CapeValidationStatus)
		};
		let val_status=match CapeValidationStatus::from(val_status) {
			Some(_val_status) => _val_status,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(val_status)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn calculate(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Calculate.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_valid:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_valid as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_valid)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeUnitPort
///
///ICapeUnitPort interface
///
pub trait ICapeUnitPort {
	fn get_port_type(&mut self) -> Result<CapePortType,COBIAError>;
	fn get_direction(&mut self) -> Result<CapePortDirection,COBIAError>;
	fn get_connected_object(&mut self) -> Result<crate::CapeObject,COBIAError>;
	fn connect(&mut self,object_to_connect:crate::CapeObject) -> Result<(),COBIAError>;
	fn disconnect(&mut self) -> Result<(),COBIAError>;
}

pub trait ICapeUnitPortImpl : ICapeUnitPort {
	type T: ICapeInterfaceImpl+ICapeUnitPortImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeUnitPort interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeUnitPort_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeUnitPortImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeUnitPort =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeUnitPort;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeUnitPort_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_port_type(me: *mut std::ffi::c_void,port_type:*mut C::CAPEOPEN_1_2_CapePortType) -> crate::C::CapeResult {
		if port_type.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_port_type() {
			Ok(_port_type) => {
				unsafe{*port_type=_port_type as C::CAPEOPEN_1_2_CapePortType;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeUnitPort::GetPortType")
		}
	}

	extern "C" fn raw_get_direction(me: *mut std::ffi::c_void,port_direction:*mut C::CAPEOPEN_1_2_CapePortDirection) -> crate::C::CapeResult {
		if port_direction.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_direction() {
			Ok(_port_direction) => {
				unsafe{*port_direction=_port_direction as C::CAPEOPEN_1_2_CapePortDirection;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeUnitPort::GetDirection")
		}
	}

	extern "C" fn raw_get_connected_object(me: *mut std::ffi::c_void,connected_object:*mut *mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if connected_object.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if connected_object.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		match myself.get_connected_object() {
			Ok(_connected_object) => {
				unsafe{*connected_object=_connected_object.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeUnitPort::GetConnectedObject")
		}
	}

	extern "C" fn raw_connect(me: *mut std::ffi::c_void,object_to_connect:*mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if object_to_connect.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if object_to_connect.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let object_to_connect=crate::CapeObject::from_interface_pointer(object_to_connect);
		match myself.connect(object_to_connect) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeUnitPort::Connect")
		}
	}

	extern "C" fn raw_disconnect(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.disconnect() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeUnitPort::Disconnect")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeUnitPort_VTable =
		C::CAPEOPEN_1_2_ICapeUnitPort_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getPortType: Some(Self::T::raw_get_port_type),
			getDirection: Some(Self::T::raw_get_direction),
			getConnectedObject: Some(Self::T::raw_get_connected_object),
			Connect: Some(Self::T::raw_connect),
			Disconnect: Some(Self::T::raw_disconnect),
		};
}

#[cape_smart_pointer(ICAPEUNITPORT_UUID)]
pub struct CapeUnitPort {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeUnitPort,
}

impl CapeUnitPort {

	pub fn get_port_type(&self) -> Result<CapePortType,COBIAError> {
		let mut port_type:C::CAPEOPEN_1_2_CapePortType=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getPortType.unwrap())((*self.interface).me,&mut port_type as *mut C::CAPEOPEN_1_2_CapePortType)
		};
		let port_type=match CapePortType::from(port_type) {
			Some(_port_type) => _port_type,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(port_type)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_direction(&self) -> Result<CapePortDirection,COBIAError> {
		let mut port_direction:C::CAPEOPEN_1_2_CapePortDirection=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getDirection.unwrap())((*self.interface).me,&mut port_direction as *mut C::CAPEOPEN_1_2_CapePortDirection)
		};
		let port_direction=match CapePortDirection::from(port_direction) {
			Some(_port_direction) => _port_direction,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(port_direction)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_connected_object(&self) -> Result<crate::CapeObject,COBIAError> {
		let mut connected_object: *mut crate::C::ICapeInterface=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).getConnectedObject.unwrap())((*self.interface).me,&mut connected_object as *mut *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(crate::CapeObject::attach(connected_object))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn connect(&self,object_to_connect:&crate::CapeObject) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Connect.unwrap())((*self.interface).me,object_to_connect.as_interface_pointer() as *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn disconnect(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Disconnect.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapePersistWriter
///
///ICapePersistWriter interface
///
pub trait ICapePersistWriter {
	fn add_real(&mut self,value_name:&CapeStringIn,value:CapeReal) -> Result<(),COBIAError>;
	fn add_integer(&mut self,value_name:&CapeStringIn,value:CapeInteger) -> Result<(),COBIAError>;
	fn add_boolean(&mut self,value_name:&CapeStringIn,value:CapeBoolean) -> Result<(),COBIAError>;
	fn add_string(&mut self,value_name:&CapeStringIn,value:&CapeStringIn) -> Result<(),COBIAError>;
	fn add_enumeration(&mut self,value_name:&CapeStringIn,value:crate::CapeEnumeration) -> Result<(),COBIAError>;
	fn add_value(&mut self,value_name:&CapeStringIn,value:&CapeValueIn) -> Result<(),COBIAError>;
	fn add_array_real(&mut self,value_name:&CapeStringIn,value:&CapeArrayRealIn) -> Result<(),COBIAError>;
	fn add_array_integer(&mut self,value_name:&CapeStringIn,value:&CapeArrayIntegerIn) -> Result<(),COBIAError>;
	fn add_array_boolean(&mut self,value_name:&CapeStringIn,value:&CapeArrayBooleanIn) -> Result<(),COBIAError>;
	fn add_array_string(&mut self,value_name:&CapeStringIn,value:&CapeArrayStringIn) -> Result<(),COBIAError>;
	fn add_array_enumeration(&mut self,value_name:&CapeStringIn,value:&CapeArrayEnumerationIn<CapeEnumeration>) -> Result<(),COBIAError>;
	fn add_array_value(&mut self,value_name:&CapeStringIn,value:&CapeArrayValueIn) -> Result<(),COBIAError>;
	fn add_array_byte(&mut self,value_name:&CapeStringIn,value:&CapeArrayByteIn) -> Result<(),COBIAError>;
	fn add_node(&mut self,node_name:&CapeStringIn) -> Result<CapePersistWriter,COBIAError>;
}

pub trait ICapePersistWriterImpl : ICapePersistWriter {
	type T: ICapeInterfaceImpl+ICapePersistWriterImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapePersistWriter interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapePersistWriter_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapePersistWriterImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapePersistWriter =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapePersistWriter;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapePersistWriter_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_add_real(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:CapeReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.add_real(&value_name,value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddReal")
		}
	}

	extern "C" fn raw_add_integer(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:CapeInteger) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.add_integer(&value_name,value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddInteger")
		}
	}

	extern "C" fn raw_add_boolean(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:CapeBoolean) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.add_boolean(&value_name,value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddBoolean")
		}
	}

	extern "C" fn raw_add_string(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeStringIn::new(&value);
		match myself.add_string(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddString")
		}
	}

	extern "C" fn raw_add_enumeration(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:crate::C::CapeEnumeration) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.add_enumeration(&value_name,value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddEnumeration")
		}
	}

	extern "C" fn raw_add_value(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeValue) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeValueIn::new(&value);
		match myself.add_value(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddValue")
		}
	}

	extern "C" fn raw_add_array_real(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeArrayRealIn::new(&value);
		match myself.add_array_real(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddArrayReal")
		}
	}

	extern "C" fn raw_add_array_integer(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayInteger) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeArrayIntegerIn::new(&value);
		match myself.add_array_integer(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddArrayInteger")
		}
	}

	extern "C" fn raw_add_array_boolean(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayBoolean) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeArrayBooleanIn::new(&value);
		match myself.add_array_boolean(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddArrayBoolean")
		}
	}

	extern "C" fn raw_add_array_string(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeArrayStringIn::new(&value);
		match myself.add_array_string(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddArrayString")
		}
	}

	extern "C" fn raw_add_array_enumeration(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayEnumeration) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeArrayEnumerationIn::<CapeEnumeration>::new(&value);
		match myself.add_array_enumeration(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddArrayEnumeration")
		}
	}

	extern "C" fn raw_add_array_value(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayValue) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeArrayValueIn::new(&value);
		match myself.add_array_value(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddArrayValue")
		}
	}

	extern "C" fn raw_add_array_byte(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayByte) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		let value=CapeArrayByteIn::new(&value);
		match myself.add_array_byte(&value_name,&value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddArrayByte")
		}
	}

	extern "C" fn raw_add_node(me: *mut std::ffi::c_void,node_name:*mut crate::C::ICapeString,value:*mut *mut C::CAPEOPEN_1_2_ICapePersistWriter) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let node_name=CapeStringIn::new(&node_name);
		match myself.add_node(&node_name) {
			Ok(_value) => {
				unsafe{*value=_value.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapePersistWriter::AddNode")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapePersistWriter_VTable =
		C::CAPEOPEN_1_2_ICapePersistWriter_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			AddReal: Some(Self::T::raw_add_real),
			AddInteger: Some(Self::T::raw_add_integer),
			AddBoolean: Some(Self::T::raw_add_boolean),
			AddString: Some(Self::T::raw_add_string),
			AddEnumeration: Some(Self::T::raw_add_enumeration),
			AddValue: Some(Self::T::raw_add_value),
			AddArrayReal: Some(Self::T::raw_add_array_real),
			AddArrayInteger: Some(Self::T::raw_add_array_integer),
			AddArrayBoolean: Some(Self::T::raw_add_array_boolean),
			AddArrayString: Some(Self::T::raw_add_array_string),
			AddArrayEnumeration: Some(Self::T::raw_add_array_enumeration),
			AddArrayValue: Some(Self::T::raw_add_array_value),
			AddArrayByte: Some(Self::T::raw_add_array_byte),
			AddNode: Some(Self::T::raw_add_node),
		};
}

#[cape_smart_pointer(ICAPEPERSISTWRITER_UUID)]
pub struct CapePersistWriter {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapePersistWriter,
}

impl CapePersistWriter {

	pub fn add_real<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName,value:CapeReal) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddReal.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_integer<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName,value:CapeInteger) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddInteger.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_boolean<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName,value:CapeBoolean) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddBoolean.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_string<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeStringProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddString.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_enumeration<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName,value:crate::CapeEnumeration) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddEnumeration.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_value<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeValueProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddValue.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_value_in() as *const crate::C::ICapeValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_array_real<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayRealProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddArrayReal.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_array_integer<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayIntegerProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddArrayInteger.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_integer_in() as *const crate::C::ICapeArrayInteger).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_array_boolean<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayBooleanProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddArrayBoolean.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_boolean_in() as *const crate::C::ICapeArrayBoolean).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_array_string<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayStringProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddArrayString.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_string_in() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_array_enumeration<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayEnumerationProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddArrayEnumeration.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_enumeration_in() as *const crate::C::ICapeArrayEnumeration).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_array_value<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayValueProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddArrayValue.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_value_in() as *const crate::C::ICapeArrayValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_array_byte<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayByteProviderIn>(&self,value_name:&TypeOfValueName,value:&TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddArrayByte.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_byte_in() as *const crate::C::ICapeArrayByte).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn add_node<TypeOfNodeName:CapeStringProviderIn>(&self,node_name:&TypeOfNodeName) -> Result<CapePersistWriter,COBIAError> {
		let mut value: *mut C::CAPEOPEN_1_2_ICapePersistWriter=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).AddNode.unwrap())((*self.interface).me,(&node_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut value as *mut *mut C::CAPEOPEN_1_2_ICapePersistWriter)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(CapePersistWriter::attach(value))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapePersistReader
///
///ICapePersistReader interface
///
pub trait ICapePersistReader {
	fn get_value_names(&mut self,value_names:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_value_type(&mut self,value_name:&CapeStringIn) -> Result<CapePersistedDataType,COBIAError>;
	fn get_real(&mut self,value_name:&CapeStringIn) -> Result<CapeReal,COBIAError>;
	fn get_integer(&mut self,value_name:&CapeStringIn) -> Result<CapeInteger,COBIAError>;
	fn get_boolean(&mut self,value_name:&CapeStringIn) -> Result<CapeBoolean,COBIAError>;
	fn get_string(&mut self,value_name:&CapeStringIn,value:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn get_enumeration(&mut self,value_name:&CapeStringIn) -> Result<crate::CapeEnumeration,COBIAError>;
	fn get_value(&mut self,value_name:&CapeStringIn,value:&mut CapeValueOut) -> Result<(),COBIAError>;
	fn get_array_real(&mut self,value_name:&CapeStringIn,value:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn get_array_integer(&mut self,value_name:&CapeStringIn,value:&mut CapeArrayIntegerOut) -> Result<(),COBIAError>;
	fn get_array_boolean(&mut self,value_name:&CapeStringIn,value:&mut CapeArrayBooleanOut) -> Result<(),COBIAError>;
	fn get_array_string(&mut self,value_name:&CapeStringIn,value:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_array_enumeration(&mut self,value_name:&CapeStringIn,value:&mut CapeArrayEnumerationOut<CapeEnumeration>) -> Result<(),COBIAError>;
	fn get_array_value(&mut self,value_name:&CapeStringIn,value:&mut CapeArrayValueOut) -> Result<(),COBIAError>;
	fn get_array_byte(&mut self,value_name:&CapeStringIn,value:&mut CapeArrayByteOut) -> Result<(),COBIAError>;
	fn get_node_names(&mut self,node_names:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_node(&mut self,node_name:&CapeStringIn) -> Result<CapePersistReader,COBIAError>;
}

pub trait ICapePersistReaderImpl : ICapePersistReader {
	type T: ICapeInterfaceImpl+ICapePersistReaderImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapePersistReader interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapePersistReader_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapePersistReaderImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapePersistReader =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapePersistReader;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapePersistReader_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_value_names(me: *mut std::ffi::c_void,value_names:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if value_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut value_names=unsafe{*((&value_names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut value_names=CapeArrayStringOut::new(&mut value_names);
		match myself.get_value_names(&mut value_names) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetValueNames")
		}
	}

	extern "C" fn raw_get_value_type(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value_type:*mut C::CAPEOPEN_1_2_CapePersistedDataType) -> crate::C::CapeResult {
		if value_type.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.get_value_type(&value_name) {
			Ok(_value_type) => {
				unsafe{*value_type=_value_type as C::CAPEOPEN_1_2_CapePersistedDataType;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetValueType")
		}
	}

	extern "C" fn raw_get_real(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut CapeReal) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.get_real(&value_name) {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetReal")
		}
	}

	extern "C" fn raw_get_integer(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut CapeInteger) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.get_integer(&value_name) {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetInteger")
		}
	}

	extern "C" fn raw_get_boolean(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut CapeBoolean) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.get_boolean(&value_name) {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetBoolean")
		}
	}

	extern "C" fn raw_get_string(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut value=CapeStringOut::new(&mut value);
		match myself.get_string(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetString")
		}
	}

	extern "C" fn raw_get_enumeration(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::CapeEnumeration) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let value_name=CapeStringIn::new(&value_name);
		match myself.get_enumeration(&value_name) {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetEnumeration")
		}
	}

	extern "C" fn raw_get_value(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeValue) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeValue) as *mut *mut crate::C::ICapeValue)};
		let mut value=CapeValueOut::new(&mut value);
		match myself.get_value(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetValue")
		}
	}

	extern "C" fn raw_get_array_real(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut value=CapeArrayRealOut::new(&mut value);
		match myself.get_array_real(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetArrayReal")
		}
	}

	extern "C" fn raw_get_array_integer(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayInteger) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayInteger) as *mut *mut crate::C::ICapeArrayInteger)};
		let mut value=CapeArrayIntegerOut::new(&mut value);
		match myself.get_array_integer(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetArrayInteger")
		}
	}

	extern "C" fn raw_get_array_boolean(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayBoolean) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayBoolean) as *mut *mut crate::C::ICapeArrayBoolean)};
		let mut value=CapeArrayBooleanOut::new(&mut value);
		match myself.get_array_boolean(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetArrayBoolean")
		}
	}

	extern "C" fn raw_get_array_string(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut value=CapeArrayStringOut::new(&mut value);
		match myself.get_array_string(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetArrayString")
		}
	}

	extern "C" fn raw_get_array_enumeration(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayEnumeration) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayEnumeration) as *mut *mut crate::C::ICapeArrayEnumeration)};
		let mut value=CapeArrayEnumerationOut::<CapeEnumeration>::new(&mut value);
		match myself.get_array_enumeration(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetArrayEnumeration")
		}
	}

	extern "C" fn raw_get_array_value(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayValue) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayValue) as *mut *mut crate::C::ICapeArrayValue)};
		let mut value=CapeArrayValueOut::new(&mut value);
		match myself.get_array_value(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetArrayValue")
		}
	}

	extern "C" fn raw_get_array_byte(me: *mut std::ffi::c_void,value_name:*mut crate::C::ICapeString,value:*mut crate::C::ICapeArrayByte) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let value_name=CapeStringIn::new(&value_name);
		let mut value=unsafe{*((&value as *const *mut crate::C::ICapeArrayByte) as *mut *mut crate::C::ICapeArrayByte)};
		let mut value=CapeArrayByteOut::new(&mut value);
		match myself.get_array_byte(&value_name,&mut value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetArrayByte")
		}
	}

	extern "C" fn raw_get_node_names(me: *mut std::ffi::c_void,node_names:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if node_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if node_names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut node_names=unsafe{*((&node_names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut node_names=CapeArrayStringOut::new(&mut node_names);
		match myself.get_node_names(&mut node_names) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetNodeNames")
		}
	}

	extern "C" fn raw_get_node(me: *mut std::ffi::c_void,node_name:*mut crate::C::ICapeString,value:*mut *mut C::CAPEOPEN_1_2_ICapePersistReader) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let node_name=CapeStringIn::new(&node_name);
		match myself.get_node(&node_name) {
			Ok(_value) => {
				unsafe{*value=_value.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapePersistReader::GetNode")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapePersistReader_VTable =
		C::CAPEOPEN_1_2_ICapePersistReader_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getValueNames: Some(Self::T::raw_get_value_names),
			GetValueType: Some(Self::T::raw_get_value_type),
			GetReal: Some(Self::T::raw_get_real),
			GetInteger: Some(Self::T::raw_get_integer),
			GetBoolean: Some(Self::T::raw_get_boolean),
			GetString: Some(Self::T::raw_get_string),
			GetEnumeration: Some(Self::T::raw_get_enumeration),
			GetValue: Some(Self::T::raw_get_value),
			GetArrayReal: Some(Self::T::raw_get_array_real),
			GetArrayInteger: Some(Self::T::raw_get_array_integer),
			GetArrayBoolean: Some(Self::T::raw_get_array_boolean),
			GetArrayString: Some(Self::T::raw_get_array_string),
			GetArrayEnumeration: Some(Self::T::raw_get_array_enumeration),
			GetArrayValue: Some(Self::T::raw_get_array_value),
			GetArrayByte: Some(Self::T::raw_get_array_byte),
			getNodeNames: Some(Self::T::raw_get_node_names),
			GetNode: Some(Self::T::raw_get_node),
		};
}

#[cape_smart_pointer(ICAPEPERSISTREADER_UUID)]
pub struct CapePersistReader {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapePersistReader,
}

impl CapePersistReader {

	pub fn get_value_names<TypeOfValueNames:CapeArrayStringProviderOut>(&self,value_names:&mut TypeOfValueNames) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValueNames.unwrap())((*self.interface).me,(&value_names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_value_type<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName) -> Result<CapePersistedDataType,COBIAError> {
		let mut value_type:C::CAPEOPEN_1_2_CapePersistedDataType=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetValueType.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut value_type as *mut C::CAPEOPEN_1_2_CapePersistedDataType)
		};
		let value_type=match CapePersistedDataType::from(value_type) {
			Some(_value_type) => _value_type,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value_type)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_real<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName) -> Result<CapeReal,COBIAError> {
		let mut value:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetReal.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut value as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_integer<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName) -> Result<CapeInteger,COBIAError> {
		let mut value:CapeInteger=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetInteger.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut value as *mut CapeInteger)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_boolean<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName) -> Result<CapeBoolean,COBIAError> {
		let mut value:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetBoolean.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut value as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_string<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeStringProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetString.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_enumeration<TypeOfValueName:CapeStringProviderIn>(&self,value_name:&TypeOfValueName) -> Result<crate::CapeEnumeration,COBIAError> {
		let mut value:crate::C::CapeEnumeration=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetEnumeration.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut value as *mut crate::C::CapeEnumeration)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_value<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeValueProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetValue.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_value_out() as *const crate::C::ICapeValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_array_real<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayRealProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetArrayReal.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_array_integer<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayIntegerProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetArrayInteger.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_integer_out() as *const crate::C::ICapeArrayInteger).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_array_boolean<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayBooleanProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetArrayBoolean.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_boolean_out() as *const crate::C::ICapeArrayBoolean).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_array_string<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayStringProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetArrayString.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_array_enumeration<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayEnumerationProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetArrayEnumeration.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_enumeration_out() as *const crate::C::ICapeArrayEnumeration).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_array_value<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayValueProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetArrayValue.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_value_out() as *const crate::C::ICapeArrayValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_array_byte<TypeOfValueName:CapeStringProviderIn,TypeOfValue:CapeArrayByteProviderOut>(&self,value_name:&TypeOfValueName,value:&mut TypeOfValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetArrayByte.unwrap())((*self.interface).me,(&value_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&value.as_cape_array_byte_out() as *const crate::C::ICapeArrayByte).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_node_names<TypeOfNodeNames:CapeArrayStringProviderOut>(&self,node_names:&mut TypeOfNodeNames) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getNodeNames.unwrap())((*self.interface).me,(&node_names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_node<TypeOfNodeName:CapeStringProviderIn>(&self,node_name:&TypeOfNodeName) -> Result<CapePersistReader,COBIAError> {
		let mut value: *mut C::CAPEOPEN_1_2_ICapePersistReader=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetNode.unwrap())((*self.interface).me,(&node_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut value as *mut *mut C::CAPEOPEN_1_2_ICapePersistReader)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(CapePersistReader::attach(value))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapePersist
///
///ICapePersist interface
///
pub trait ICapePersist {
	fn save(&mut self,writer:CapePersistWriter,clear_dirty:CapeBoolean) -> Result<(),COBIAError>;
	fn load(&mut self,reader:CapePersistReader) -> Result<(),COBIAError>;
	fn get_is_dirty(&mut self) -> Result<CapeBoolean,COBIAError>;
}

pub trait ICapePersistImpl : ICapePersist {
	type T: ICapeInterfaceImpl+ICapePersistImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapePersist interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapePersist_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapePersistImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapePersist =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapePersist;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapePersist_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_save(me: *mut std::ffi::c_void,writer:*mut C::CAPEOPEN_1_2_ICapePersistWriter,clear_dirty:CapeBoolean) -> crate::C::CapeResult {
		if writer.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if writer.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let writer=CapePersistWriter::from_interface_pointer(writer);
		match myself.save(writer,clear_dirty) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersist::Save")
		}
	}

	extern "C" fn raw_load(me: *mut std::ffi::c_void,reader:*mut C::CAPEOPEN_1_2_ICapePersistReader) -> crate::C::CapeResult {
		if reader.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if reader.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let reader=CapePersistReader::from_interface_pointer(reader);
		match myself.load(reader) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapePersist::Load")
		}
	}

	extern "C" fn raw_get_is_dirty(me: *mut std::ffi::c_void,dirty:*mut CapeBoolean) -> crate::C::CapeResult {
		if dirty.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_is_dirty() {
			Ok(_dirty) => {
				unsafe{*dirty=_dirty;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapePersist::GetIsDirty")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapePersist_VTable =
		C::CAPEOPEN_1_2_ICapePersist_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			Save: Some(Self::T::raw_save),
			Load: Some(Self::T::raw_load),
			getIsDirty: Some(Self::T::raw_get_is_dirty),
		};
}

#[cape_smart_pointer(ICAPEPERSIST_UUID)]
pub struct CapePersist {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapePersist,
}

impl CapePersist {

	pub fn save(&self,writer:&CapePersistWriter,clear_dirty:CapeBoolean) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Save.unwrap())((*self.interface).me,writer.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapePersistWriter,clear_dirty)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn load(&self,reader:&CapePersistReader) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Load.unwrap())((*self.interface).me,reader.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapePersistReader)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_is_dirty(&self) -> Result<CapeBoolean,COBIAError> {
		let mut dirty:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getIsDirty.unwrap())((*self.interface).me,&mut dirty as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(dirty)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeReport
///
///ICapeReport interface
///
pub trait ICapeReport {
	fn get_report_names(&mut self,names:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn report_types(&mut self,name:&CapeStringIn,types:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn report_locales(&mut self,name:&CapeStringIn,_type:&CapeStringIn,locales:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn check_report_spec(&mut self,name:&CapeStringIn,_type:&CapeStringIn,locale:&CapeStringIn) -> Result<CapeBoolean,COBIAError>;
	fn generate_report(&mut self,name:&CapeStringIn,_type:&CapeStringIn,locale:&CapeStringIn,report_content:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn generate_report_file(&mut self,name:&CapeStringIn,_type:&CapeStringIn,locale:&CapeStringIn,file_name:&CapeStringIn) -> Result<(),COBIAError>;
}

pub trait ICapeReportImpl : ICapeReport {
	type T: ICapeInterfaceImpl+ICapeReportImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeReport interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeReport_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeReportImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeReport =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeReport;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeReport_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_report_names(me: *mut std::ffi::c_void,names:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if names.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut names=unsafe{*((&names as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut names=CapeArrayStringOut::new(&mut names);
		match myself.get_report_names(&mut names) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeReport::GetReportNames")
		}
	}

	extern "C" fn raw_report_types(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString,types:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if types.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if types.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let name=CapeStringIn::new(&name);
		let mut types=unsafe{*((&types as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut types=CapeArrayStringOut::new(&mut types);
		match myself.report_types(&name,&mut types) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeReport::ReportTypes")
		}
	}

	extern "C" fn raw_report_locales(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString,_type:*mut crate::C::ICapeString,locales:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if locales.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if locales.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let name=CapeStringIn::new(&name);
		let _type=CapeStringIn::new(&_type);
		let mut locales=unsafe{*((&locales as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut locales=CapeArrayStringOut::new(&mut locales);
		match myself.report_locales(&name,&_type,&mut locales) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeReport::ReportLocales")
		}
	}

	extern "C" fn raw_check_report_spec(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString,_type:*mut crate::C::ICapeString,locale:*mut crate::C::ICapeString,report_available:*mut CapeBoolean) -> crate::C::CapeResult {
		if report_available.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let name=CapeStringIn::new(&name);
		let _type=CapeStringIn::new(&_type);
		let locale=CapeStringIn::new(&locale);
		match myself.check_report_spec(&name,&_type,&locale) {
			Ok(_report_available) => {
				unsafe{*report_available=_report_available;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeReport::CheckReportSpec")
		}
	}

	extern "C" fn raw_generate_report(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString,_type:*mut crate::C::ICapeString,locale:*mut crate::C::ICapeString,report_content:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if report_content.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if report_content.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let name=CapeStringIn::new(&name);
		let _type=CapeStringIn::new(&_type);
		let locale=CapeStringIn::new(&locale);
		let mut report_content=unsafe{*((&report_content as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut report_content=CapeStringOut::new(&mut report_content);
		match myself.generate_report(&name,&_type,&locale,&mut report_content) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeReport::GenerateReport")
		}
	}

	extern "C" fn raw_generate_report_file(me: *mut std::ffi::c_void,name:*mut crate::C::ICapeString,_type:*mut crate::C::ICapeString,locale:*mut crate::C::ICapeString,file_name:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let name=CapeStringIn::new(&name);
		let _type=CapeStringIn::new(&_type);
		let locale=CapeStringIn::new(&locale);
		let file_name=CapeStringIn::new(&file_name);
		match myself.generate_report_file(&name,&_type,&locale,&file_name) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeReport::GenerateReportFile")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeReport_VTable =
		C::CAPEOPEN_1_2_ICapeReport_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			getReportNames: Some(Self::T::raw_get_report_names),
			ReportTypes: Some(Self::T::raw_report_types),
			ReportLocales: Some(Self::T::raw_report_locales),
			CheckReportSpec: Some(Self::T::raw_check_report_spec),
			GenerateReport: Some(Self::T::raw_generate_report),
			GenerateReportFile: Some(Self::T::raw_generate_report_file),
		};
}

#[cape_smart_pointer(ICAPEREPORT_UUID)]
pub struct CapeReport {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeReport,
}

impl CapeReport {

	pub fn get_report_names<TypeOfNames:CapeArrayStringProviderOut>(&self,names:&mut TypeOfNames) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getReportNames.unwrap())((*self.interface).me,(&names.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn report_types<TypeOfName:CapeStringProviderIn,TypeOfTypes:CapeArrayStringProviderOut>(&self,name:&TypeOfName,types:&mut TypeOfTypes) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).ReportTypes.unwrap())((*self.interface).me,(&name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&types.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn report_locales<TypeOfName:CapeStringProviderIn,TypeOfType:CapeStringProviderIn,TypeOfLocales:CapeArrayStringProviderOut>(&self,name:&TypeOfName,_type:&TypeOfType,locales:&mut TypeOfLocales) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).ReportLocales.unwrap())((*self.interface).me,(&name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&_type.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&locales.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn check_report_spec<TypeOfName:CapeStringProviderIn,TypeOfType:CapeStringProviderIn,TypeOfLocale:CapeStringProviderIn>(&self,name:&TypeOfName,_type:&TypeOfType,locale:&TypeOfLocale) -> Result<CapeBoolean,COBIAError> {
		let mut report_available:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).CheckReportSpec.unwrap())((*self.interface).me,(&name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&_type.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&locale.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut report_available as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(report_available)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn generate_report<TypeOfName:CapeStringProviderIn,TypeOfType:CapeStringProviderIn,TypeOfLocale:CapeStringProviderIn,TypeOfReportContent:CapeStringProviderOut>(&self,name:&TypeOfName,_type:&TypeOfType,locale:&TypeOfLocale,report_content:&mut TypeOfReportContent) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GenerateReport.unwrap())((*self.interface).me,(&name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&_type.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&locale.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&report_content.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn generate_report_file<TypeOfName:CapeStringProviderIn,TypeOfType:CapeStringProviderIn,TypeOfLocale:CapeStringProviderIn,TypeOfFileName:CapeStringProviderIn>(&self,name:&TypeOfName,_type:&TypeOfType,locale:&TypeOfLocale,file_name:&TypeOfFileName) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GenerateReportFile.unwrap())((*self.interface).me,(&name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&_type.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&locale.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&file_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeFlowsheetMonitoringComponent
///
///ICapeFlowsheetMonitoringComponent interface
///
pub trait ICapeFlowsheetMonitoringComponent {
	fn monitor(&mut self) -> Result<(),COBIAError>;
	fn validate(&mut self,message:&mut CapeStringOut) -> Result<CapeBoolean,COBIAError>;
	fn get_val_status(&mut self) -> Result<CapeValidationStatus,COBIAError>;
}

pub trait ICapeFlowsheetMonitoringComponentImpl : ICapeFlowsheetMonitoringComponent {
	type T: ICapeInterfaceImpl+ICapeFlowsheetMonitoringComponentImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeFlowsheetMonitoringComponent interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringComponent_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeFlowsheetMonitoringComponentImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringComponent =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringComponent;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringComponent_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_monitor(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.monitor() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringComponent::Monitor")
		}
	}

	extern "C" fn raw_validate(me: *mut std::ffi::c_void,message:*mut crate::C::ICapeString,is_valid:*mut CapeBoolean) -> crate::C::CapeResult {
		if message.is_null()||is_valid.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if message.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut message=unsafe{*((&message as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut message=CapeStringOut::new(&mut message);
		match myself.validate(&mut message) {
			Ok(_is_valid) => {
				unsafe{*is_valid=_is_valid;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringComponent::Validate")
		}
	}

	extern "C" fn raw_get_val_status(me: *mut std::ffi::c_void,validation_status:*mut C::CAPEOPEN_1_2_CapeValidationStatus) -> crate::C::CapeResult {
		if validation_status.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_val_status() {
			Ok(_validation_status) => {
				unsafe{*validation_status=_validation_status as C::CAPEOPEN_1_2_CapeValidationStatus;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringComponent::GetValStatus")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringComponent_VTable =
		C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringComponent_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			Monitor: Some(Self::T::raw_monitor),
			Validate: Some(Self::T::raw_validate),
			getValStatus: Some(Self::T::raw_get_val_status),
		};
}

#[cape_smart_pointer(ICAPEFLOWSHEETMONITORINGCOMPONENT_UUID)]
pub struct CapeFlowsheetMonitoringComponent {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringComponent,
}

impl CapeFlowsheetMonitoringComponent {

	pub fn monitor(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).Monitor.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn validate<TypeOfMessage:CapeStringProviderOut>(&self,message:&mut TypeOfMessage) -> Result<CapeBoolean,COBIAError> {
		let mut is_valid:CapeBoolean=false as CapeBoolean;
		let result_code = unsafe {
			((*(*self.interface).vTbl).Validate.unwrap())((*self.interface).me,(&message.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),&mut is_valid as *mut CapeBoolean)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(is_valid)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_val_status(&self) -> Result<CapeValidationStatus,COBIAError> {
		let mut validation_status:C::CAPEOPEN_1_2_CapeValidationStatus=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValStatus.unwrap())((*self.interface).me,&mut validation_status as *mut C::CAPEOPEN_1_2_CapeValidationStatus)
		};
		let validation_status=match CapeValidationStatus::from(validation_status) {
			Some(_validation_status) => _validation_status,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(validation_status)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeStream
///
///ICapeStream interface
///
pub trait ICapeStream {
	fn stream_type(&mut self) -> Result<CapeStreamType,COBIAError>;
	fn get_stream_object(&mut self) -> Result<crate::CapeObject,COBIAError>;
	fn get_upstream_port_connection(&mut self,upstream_port:&mut CapeStringOut,upstream_unit:&mut CapeStringOut) -> Result<(),COBIAError>;
	fn get_downstream_port_connection(&mut self,downstream_port:&mut CapeStringOut,downstream_unit:&mut CapeStringOut) -> Result<(),COBIAError>;
}

pub trait ICapeStreamImpl : ICapeStream {
	type T: ICapeInterfaceImpl+ICapeStreamImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeStream interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeStream_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeStreamImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeStream =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeStream;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeStream_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_stream_type(me: *mut std::ffi::c_void,stream_type:*mut C::CAPEOPEN_1_2_CapeStreamType) -> crate::C::CapeResult {
		if stream_type.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.stream_type() {
			Ok(_stream_type) => {
				unsafe{*stream_type=_stream_type as C::CAPEOPEN_1_2_CapeStreamType;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeStream::StreamType")
		}
	}

	extern "C" fn raw_get_stream_object(me: *mut std::ffi::c_void,stream_object:*mut *mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if stream_object.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if stream_object.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		match myself.get_stream_object() {
			Ok(_stream_object) => {
				unsafe{*stream_object=_stream_object.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeStream::GetStreamObject")
		}
	}

	extern "C" fn raw_get_upstream_port_connection(me: *mut std::ffi::c_void,upstream_port:*mut crate::C::ICapeString,upstream_unit:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if upstream_port.is_null()||upstream_unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if upstream_port.is_null()||upstream_unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut upstream_port=unsafe{*((&upstream_port as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut upstream_port=CapeStringOut::new(&mut upstream_port);
		let mut upstream_unit=unsafe{*((&upstream_unit as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut upstream_unit=CapeStringOut::new(&mut upstream_unit);
		match myself.get_upstream_port_connection(&mut upstream_port,&mut upstream_unit) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeStream::GetUpstreamPortConnection")
		}
	}

	extern "C" fn raw_get_downstream_port_connection(me: *mut std::ffi::c_void,downstream_port:*mut crate::C::ICapeString,downstream_unit:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if downstream_port.is_null()||downstream_unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if downstream_port.is_null()||downstream_unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut downstream_port=unsafe{*((&downstream_port as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut downstream_port=CapeStringOut::new(&mut downstream_port);
		let mut downstream_unit=unsafe{*((&downstream_unit as *const *mut crate::C::ICapeString) as *mut *mut crate::C::ICapeString)};
		let mut downstream_unit=CapeStringOut::new(&mut downstream_unit);
		match myself.get_downstream_port_connection(&mut downstream_port,&mut downstream_unit) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeStream::GetDownstreamPortConnection")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeStream_VTable =
		C::CAPEOPEN_1_2_ICapeStream_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			StreamType: Some(Self::T::raw_stream_type),
			getStreamObject: Some(Self::T::raw_get_stream_object),
			GetUpstreamPortConnection: Some(Self::T::raw_get_upstream_port_connection),
			GetDownstreamPortConnection: Some(Self::T::raw_get_downstream_port_connection),
		};
}

#[cape_smart_pointer(ICAPESTREAM_UUID)]
pub struct CapeStream {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeStream,
}

impl CapeStream {

	pub fn stream_type(&self) -> Result<CapeStreamType,COBIAError> {
		let mut stream_type:C::CAPEOPEN_1_2_CapeStreamType=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).StreamType.unwrap())((*self.interface).me,&mut stream_type as *mut C::CAPEOPEN_1_2_CapeStreamType)
		};
		let stream_type=match CapeStreamType::from(stream_type) {
			Some(_stream_type) => _stream_type,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(stream_type)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_stream_object(&self) -> Result<crate::CapeObject,COBIAError> {
		let mut stream_object: *mut crate::C::ICapeInterface=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).getStreamObject.unwrap())((*self.interface).me,&mut stream_object as *mut *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(crate::CapeObject::attach(stream_object))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_upstream_port_connection<TypeOfUpstreamPort:CapeStringProviderOut,TypeOfUpstreamUnit:CapeStringProviderOut>(&self,upstream_port:&mut TypeOfUpstreamPort,upstream_unit:&mut TypeOfUpstreamUnit) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetUpstreamPortConnection.unwrap())((*self.interface).me,(&upstream_port.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),(&upstream_unit.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_downstream_port_connection<TypeOfDownstreamPort:CapeStringProviderOut,TypeOfDownstreamUnit:CapeStringProviderOut>(&self,downstream_port:&mut TypeOfDownstreamPort,downstream_unit:&mut TypeOfDownstreamUnit) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetDownstreamPortConnection.unwrap())((*self.interface).me,(&downstream_port.as_cape_string_out() as *const crate::C::ICapeString).cast_mut(),(&downstream_unit.as_cape_string_out() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeFlowsheetMonitoringEventSink
///
///ICapeFlowsheetMonitoringEventSink interface
///
pub trait ICapeFlowsheetMonitoringEventSink {
	fn unit_operation_added(&mut self,unit:CapeUnit) -> Result<(),COBIAError>;
	fn unit_operation_removed(&mut self,unit:CapeUnit) -> Result<(),COBIAError>;
	fn unit_operation_renamed(&mut self,unit:CapeUnit,old_name:&CapeStringIn) -> Result<(),COBIAError>;
	fn stream_added(&mut self,stream:CapeStream,_type:CapeStreamType) -> Result<(),COBIAError>;
	fn stream_removed(&mut self,stream:CapeStream,_type:CapeStreamType) -> Result<(),COBIAError>;
	fn stream_renamed(&mut self,stream:CapeStream,_type:CapeStreamType,old_name:&CapeStringIn) -> Result<(),COBIAError>;
	fn connection_changed(&mut self,stream:CapeStream,_type:CapeStreamType,port:CapeUnitPort,unit:CapeUnit) -> Result<(),COBIAError>;
	fn flowsheet_solution_status_changed(&mut self,solution_status:CapeSolutionStatus) -> Result<(),COBIAError>;
	fn flowsheet_validation_state_changed(&mut self,validation_status:CapeValidationStatus) -> Result<(),COBIAError>;
	fn next_time_step(&mut self) -> Result<(),COBIAError>;
}

pub trait ICapeFlowsheetMonitoringEventSinkImpl : ICapeFlowsheetMonitoringEventSink {
	type T: ICapeInterfaceImpl+ICapeFlowsheetMonitoringEventSinkImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeFlowsheetMonitoringEventSink interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringEventSink_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeFlowsheetMonitoringEventSinkImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringEventSink =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringEventSink;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringEventSink_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_unit_operation_added(me: *mut std::ffi::c_void,unit:*mut C::CAPEOPEN_1_2_ICapeUnit) -> crate::C::CapeResult {
		if unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let unit=CapeUnit::from_interface_pointer(unit);
		match myself.unit_operation_added(unit) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::UnitOperationAdded")
		}
	}

	extern "C" fn raw_unit_operation_removed(me: *mut std::ffi::c_void,unit:*mut C::CAPEOPEN_1_2_ICapeUnit) -> crate::C::CapeResult {
		if unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let unit=CapeUnit::from_interface_pointer(unit);
		match myself.unit_operation_removed(unit) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::UnitOperationRemoved")
		}
	}

	extern "C" fn raw_unit_operation_renamed(me: *mut std::ffi::c_void,unit:*mut C::CAPEOPEN_1_2_ICapeUnit,old_name:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let unit=CapeUnit::from_interface_pointer(unit);
		let old_name=CapeStringIn::new(&old_name);
		match myself.unit_operation_renamed(unit,&old_name) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::UnitOperationRenamed")
		}
	}

	extern "C" fn raw_stream_added(me: *mut std::ffi::c_void,stream:*mut C::CAPEOPEN_1_2_ICapeStream,_type:C::CAPEOPEN_1_2_CapeStreamType) -> crate::C::CapeResult {
		if stream.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if stream.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let stream=CapeStream::from_interface_pointer(stream);
		let _type=match CapeStreamType::from(_type) {
			Some(__type) => __type,
			None => {return myself.set_last_error(COBIAError::Message("Invalid enumeration value".to_string()),"ICapeFlowsheetMonitoringEventSink::StreamAdded");}
		};
		match myself.stream_added(stream,_type) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::StreamAdded")
		}
	}

	extern "C" fn raw_stream_removed(me: *mut std::ffi::c_void,stream:*mut C::CAPEOPEN_1_2_ICapeStream,_type:C::CAPEOPEN_1_2_CapeStreamType) -> crate::C::CapeResult {
		if stream.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if stream.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let stream=CapeStream::from_interface_pointer(stream);
		let _type=match CapeStreamType::from(_type) {
			Some(__type) => __type,
			None => {return myself.set_last_error(COBIAError::Message("Invalid enumeration value".to_string()),"ICapeFlowsheetMonitoringEventSink::StreamRemoved");}
		};
		match myself.stream_removed(stream,_type) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::StreamRemoved")
		}
	}

	extern "C" fn raw_stream_renamed(me: *mut std::ffi::c_void,stream:*mut C::CAPEOPEN_1_2_ICapeStream,_type:C::CAPEOPEN_1_2_CapeStreamType,old_name:*mut crate::C::ICapeString) -> crate::C::CapeResult {
		if stream.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if stream.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let stream=CapeStream::from_interface_pointer(stream);
		let _type=match CapeStreamType::from(_type) {
			Some(__type) => __type,
			None => {return myself.set_last_error(COBIAError::Message("Invalid enumeration value".to_string()),"ICapeFlowsheetMonitoringEventSink::StreamRenamed");}
		};
		let old_name=CapeStringIn::new(&old_name);
		match myself.stream_renamed(stream,_type,&old_name) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::StreamRenamed")
		}
	}

	extern "C" fn raw_connection_changed(me: *mut std::ffi::c_void,stream:*mut C::CAPEOPEN_1_2_ICapeStream,_type:C::CAPEOPEN_1_2_CapeStreamType,port:*mut C::CAPEOPEN_1_2_ICapeUnitPort,unit:*mut C::CAPEOPEN_1_2_ICapeUnit) -> crate::C::CapeResult {
		if stream.is_null()||port.is_null()||unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if stream.is_null()||port.is_null()||unit.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let stream=CapeStream::from_interface_pointer(stream);
		let _type=match CapeStreamType::from(_type) {
			Some(__type) => __type,
			None => {return myself.set_last_error(COBIAError::Message("Invalid enumeration value".to_string()),"ICapeFlowsheetMonitoringEventSink::ConnectionChanged");}
		};
		let port=CapeUnitPort::from_interface_pointer(port);
		let unit=CapeUnit::from_interface_pointer(unit);
		match myself.connection_changed(stream,_type,port,unit) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::ConnectionChanged")
		}
	}

	extern "C" fn raw_flowsheet_solution_status_changed(me: *mut std::ffi::c_void,solution_status:C::CAPEOPEN_1_2_CapeSolutionStatus) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let solution_status=match CapeSolutionStatus::from(solution_status) {
			Some(_solution_status) => _solution_status,
			None => {return myself.set_last_error(COBIAError::Message("Invalid enumeration value".to_string()),"ICapeFlowsheetMonitoringEventSink::FlowsheetSolutionStatusChanged");}
		};
		match myself.flowsheet_solution_status_changed(solution_status) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::FlowsheetSolutionStatusChanged")
		}
	}

	extern "C" fn raw_flowsheet_validation_state_changed(me: *mut std::ffi::c_void,validation_status:C::CAPEOPEN_1_2_CapeValidationStatus) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let validation_status=match CapeValidationStatus::from(validation_status) {
			Some(_validation_status) => _validation_status,
			None => {return myself.set_last_error(COBIAError::Message("Invalid enumeration value".to_string()),"ICapeFlowsheetMonitoringEventSink::FlowsheetValidationStateChanged");}
		};
		match myself.flowsheet_validation_state_changed(validation_status) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::FlowsheetValidationStateChanged")
		}
	}

	extern "C" fn raw_next_time_step(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.next_time_step() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoringEventSink::NextTimeStep")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringEventSink_VTable =
		C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringEventSink_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			UnitOperationAdded: Some(Self::T::raw_unit_operation_added),
			UnitOperationRemoved: Some(Self::T::raw_unit_operation_removed),
			UnitOperationRenamed: Some(Self::T::raw_unit_operation_renamed),
			StreamAdded: Some(Self::T::raw_stream_added),
			StreamRemoved: Some(Self::T::raw_stream_removed),
			StreamRenamed: Some(Self::T::raw_stream_renamed),
			ConnectionChanged: Some(Self::T::raw_connection_changed),
			FlowsheetSolutionStatusChanged: Some(Self::T::raw_flowsheet_solution_status_changed),
			FlowsheetValidationStateChanged: Some(Self::T::raw_flowsheet_validation_state_changed),
			NextTimeStep: Some(Self::T::raw_next_time_step),
		};
}

#[cape_smart_pointer(ICAPEFLOWSHEETMONITORINGEVENTSINK_UUID)]
pub struct CapeFlowsheetMonitoringEventSink {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeFlowsheetMonitoringEventSink,
}

impl CapeFlowsheetMonitoringEventSink {

	pub fn unit_operation_added(&self,unit:&CapeUnit) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).UnitOperationAdded.unwrap())((*self.interface).me,unit.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeUnit)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn unit_operation_removed(&self,unit:&CapeUnit) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).UnitOperationRemoved.unwrap())((*self.interface).me,unit.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeUnit)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn unit_operation_renamed<TypeOfOldName:CapeStringProviderIn>(&self,unit:&CapeUnit,old_name:&TypeOfOldName) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).UnitOperationRenamed.unwrap())((*self.interface).me,unit.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeUnit,(&old_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn stream_added(&self,stream:&CapeStream,_type:CapeStreamType) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).StreamAdded.unwrap())((*self.interface).me,stream.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeStream,_type as C::CAPEOPEN_1_2_CapeStreamType)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn stream_removed(&self,stream:&CapeStream,_type:CapeStreamType) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).StreamRemoved.unwrap())((*self.interface).me,stream.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeStream,_type as C::CAPEOPEN_1_2_CapeStreamType)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn stream_renamed<TypeOfOldName:CapeStringProviderIn>(&self,stream:&CapeStream,_type:CapeStreamType,old_name:&TypeOfOldName) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).StreamRenamed.unwrap())((*self.interface).me,stream.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeStream,_type as C::CAPEOPEN_1_2_CapeStreamType,(&old_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn connection_changed(&self,stream:&CapeStream,_type:CapeStreamType,port:&CapeUnitPort,unit:&CapeUnit) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).ConnectionChanged.unwrap())((*self.interface).me,stream.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeStream,_type as C::CAPEOPEN_1_2_CapeStreamType,port.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeUnitPort,unit.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeUnit)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn flowsheet_solution_status_changed(&self,solution_status:CapeSolutionStatus) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).FlowsheetSolutionStatusChanged.unwrap())((*self.interface).me,solution_status as C::CAPEOPEN_1_2_CapeSolutionStatus)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn flowsheet_validation_state_changed(&self,validation_status:CapeValidationStatus) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).FlowsheetValidationStateChanged.unwrap())((*self.interface).me,validation_status as C::CAPEOPEN_1_2_CapeValidationStatus)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn next_time_step(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).NextTimeStep.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeFlowsheetMonitoring
///
///ICapeFlowsheetMonitoring interface
///
pub trait ICapeFlowsheetMonitoring {
	fn get_stream_collection(&mut self,_type:CapeStreamType) -> Result<CapeCollection<CapeStream>,COBIAError>;
	fn get_unit_operation_collection(&mut self) -> Result<CapeCollection<CapeUnit>,COBIAError>;
	fn get_solution_status(&mut self) -> Result<CapeSolutionStatus,COBIAError>;
	fn get_val_status(&mut self) -> Result<CapeValidationStatus,COBIAError>;
	fn register_for_events(&mut self,component:crate::CapeObject,events:&CapeArrayEnumerationIn<CapeMonitoringEvent>) -> Result<(),COBIAError>;
	fn get_supported_events(&mut self,supported_events:&mut CapeArrayEnumerationOut<CapeMonitoringEvent>) -> Result<(),COBIAError>;
}

pub trait ICapeFlowsheetMonitoringImpl : ICapeFlowsheetMonitoring {
	type T: ICapeInterfaceImpl+ICapeFlowsheetMonitoringImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeFlowsheetMonitoring interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeFlowsheetMonitoring_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeFlowsheetMonitoringImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeFlowsheetMonitoring =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeFlowsheetMonitoring;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeFlowsheetMonitoring_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_stream_collection(me: *mut std::ffi::c_void,_type:C::CAPEOPEN_1_2_CapeStreamType,stream_collection:*mut *mut C::CAPEOPEN_1_2_ICapeCollection) -> crate::C::CapeResult {
		if stream_collection.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if stream_collection.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let _type=match CapeStreamType::from(_type) {
			Some(__type) => __type,
			None => {return myself.set_last_error(COBIAError::Message("Invalid enumeration value".to_string()),"ICapeFlowsheetMonitoring::GetStreamCollection");}
		};
		match myself.get_stream_collection(_type) {
			Ok(_stream_collection) => {
				unsafe{*stream_collection=_stream_collection.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoring::GetStreamCollection")
		}
	}

	extern "C" fn raw_get_unit_operation_collection(me: *mut std::ffi::c_void,unit_operation_collection:*mut *mut C::CAPEOPEN_1_2_ICapeCollection) -> crate::C::CapeResult {
		if unit_operation_collection.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if unit_operation_collection.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		match myself.get_unit_operation_collection() {
			Ok(_unit_operation_collection) => {
				unsafe{*unit_operation_collection=_unit_operation_collection.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoring::GetUnitOperationCollection")
		}
	}

	extern "C" fn raw_get_solution_status(me: *mut std::ffi::c_void,solution_status:*mut C::CAPEOPEN_1_2_CapeSolutionStatus) -> crate::C::CapeResult {
		if solution_status.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_solution_status() {
			Ok(_solution_status) => {
				unsafe{*solution_status=_solution_status as C::CAPEOPEN_1_2_CapeSolutionStatus;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoring::GetSolutionStatus")
		}
	}

	extern "C" fn raw_get_val_status(me: *mut std::ffi::c_void,validation_status:*mut C::CAPEOPEN_1_2_CapeValidationStatus) -> crate::C::CapeResult {
		if validation_status.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.get_val_status() {
			Ok(_validation_status) => {
				unsafe{*validation_status=_validation_status as C::CAPEOPEN_1_2_CapeValidationStatus;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoring::GetValStatus")
		}
	}

	extern "C" fn raw_register_for_events(me: *mut std::ffi::c_void,component:*mut crate::C::ICapeInterface,events:*mut crate::C::ICapeArrayEnumeration) -> crate::C::CapeResult {
		if component.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if component.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let component=crate::CapeObject::from_interface_pointer(component);
		let events=CapeArrayEnumerationIn::<CapeMonitoringEvent>::new(&events);
		match myself.register_for_events(component,&events) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoring::RegisterForEvents")
		}
	}

	extern "C" fn raw_get_supported_events(me: *mut std::ffi::c_void,supported_events:*mut crate::C::ICapeArrayEnumeration) -> crate::C::CapeResult {
		if supported_events.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if supported_events.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut supported_events=unsafe{*((&supported_events as *const *mut crate::C::ICapeArrayEnumeration) as *mut *mut crate::C::ICapeArrayEnumeration)};
		let mut supported_events=CapeArrayEnumerationOut::<CapeMonitoringEvent>::new(&mut supported_events);
		match myself.get_supported_events(&mut supported_events) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeFlowsheetMonitoring::GetSupportedEvents")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeFlowsheetMonitoring_VTable =
		C::CAPEOPEN_1_2_ICapeFlowsheetMonitoring_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			GetStreamCollection: Some(Self::T::raw_get_stream_collection),
			GetUnitOperationCollection: Some(Self::T::raw_get_unit_operation_collection),
			getSolutionStatus: Some(Self::T::raw_get_solution_status),
			getValStatus: Some(Self::T::raw_get_val_status),
			RegisterForEvents: Some(Self::T::raw_register_for_events),
			getSupportedEvents: Some(Self::T::raw_get_supported_events),
		};
}

#[cape_smart_pointer(ICAPEFLOWSHEETMONITORING_UUID)]
pub struct CapeFlowsheetMonitoring {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeFlowsheetMonitoring,
}

impl CapeFlowsheetMonitoring {

	pub fn get_stream_collection(&self,_type:CapeStreamType) -> Result<CapeCollection<CapeStream>,COBIAError> {
		let mut stream_collection: *mut C::CAPEOPEN_1_2_ICapeCollection=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetStreamCollection.unwrap())((*self.interface).me,_type as C::CAPEOPEN_1_2_CapeStreamType,&mut stream_collection as *mut *mut C::CAPEOPEN_1_2_ICapeCollection)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(CapeCollection::<CapeStream>::attach(stream_collection))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_unit_operation_collection(&self) -> Result<CapeCollection<CapeUnit>,COBIAError> {
		let mut unit_operation_collection: *mut C::CAPEOPEN_1_2_ICapeCollection=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetUnitOperationCollection.unwrap())((*self.interface).me,&mut unit_operation_collection as *mut *mut C::CAPEOPEN_1_2_ICapeCollection)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(CapeCollection::<CapeUnit>::attach(unit_operation_collection))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_solution_status(&self) -> Result<CapeSolutionStatus,COBIAError> {
		let mut solution_status:C::CAPEOPEN_1_2_CapeSolutionStatus=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getSolutionStatus.unwrap())((*self.interface).me,&mut solution_status as *mut C::CAPEOPEN_1_2_CapeSolutionStatus)
		};
		let solution_status=match CapeSolutionStatus::from(solution_status) {
			Some(_solution_status) => _solution_status,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(solution_status)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_val_status(&self) -> Result<CapeValidationStatus,COBIAError> {
		let mut validation_status:C::CAPEOPEN_1_2_CapeValidationStatus=0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).getValStatus.unwrap())((*self.interface).me,&mut validation_status as *mut C::CAPEOPEN_1_2_CapeValidationStatus)
		};
		let validation_status=match CapeValidationStatus::from(validation_status) {
			Some(_validation_status) => _validation_status,
			None => {return Err(COBIAError::Message("Invalid enumeration value".to_string()));}
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(validation_status)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn register_for_events<TypeOfEvents:CapeArrayEnumerationProviderIn>(&self,component:&crate::CapeObject,events:&TypeOfEvents) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).RegisterForEvents.unwrap())((*self.interface).me,component.as_interface_pointer() as *mut crate::C::ICapeInterface,(&events.as_cape_array_enumeration_in() as *const crate::C::ICapeArrayEnumeration).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_supported_events<TypeOfSupportedEvents:CapeArrayEnumerationProviderOut>(&self,supported_events:&mut TypeOfSupportedEvents) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).getSupportedEvents.unwrap())((*self.interface).me,(&supported_events.as_cape_array_enumeration_out() as *const crate::C::ICapeArrayEnumeration).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoMaterialCustomData
///
///ICapeThermoMaterialCustomData interface
///
pub trait ICapeThermoMaterialCustomData {
	fn get_custom_data_container(&mut self,source:crate::CapeObject) -> Result<crate::CapeObject,COBIAError>;
}

pub trait ICapeThermoMaterialCustomDataImpl : ICapeThermoMaterialCustomData {
	type T: ICapeInterfaceImpl+ICapeThermoMaterialCustomDataImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoMaterialCustomData interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoMaterialCustomData_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoMaterialCustomDataImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoMaterialCustomData =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoMaterialCustomData;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoMaterialCustomData_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_get_custom_data_container(me: *mut std::ffi::c_void,source:*mut crate::C::ICapeInterface,custom_data_container:*mut *mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if source.is_null()||custom_data_container.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if source.is_null()||custom_data_container.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let source=crate::CapeObject::from_interface_pointer(source);
		match myself.get_custom_data_container(source) {
			Ok(_custom_data_container) => {
				unsafe{*custom_data_container=_custom_data_container.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoMaterialCustomData::GetCustomDataContainer")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoMaterialCustomData_VTable =
		C::CAPEOPEN_1_2_ICapeThermoMaterialCustomData_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			GetCustomDataContainer: Some(Self::T::raw_get_custom_data_container),
		};
}

#[cape_smart_pointer(ICAPETHERMOMATERIALCUSTOMDATA_UUID)]
pub struct CapeThermoMaterialCustomData {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoMaterialCustomData,
}

impl CapeThermoMaterialCustomData {

	pub fn get_custom_data_container(&self,source:&crate::CapeObject) -> Result<crate::CapeObject,COBIAError> {
		let mut custom_data_container: *mut crate::C::ICapeInterface=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetCustomDataContainer.unwrap())((*self.interface).me,source.as_interface_pointer() as *mut crate::C::ICapeInterface,&mut custom_data_container as *mut *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(crate::CapeObject::attach(custom_data_container))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeCustomDataSource
///
///ICapeCustomDataSource interface
///
pub trait ICapeCustomDataSource {
	fn create_custom_data_container(&mut self) -> Result<crate::CapeObject,COBIAError>;
	fn copy_custom_data(&mut self,source:crate::CapeObject,target:crate::CapeObject) -> Result<(),COBIAError>;
	fn thermodynamic_configuration_changed(&mut self,container:crate::CapeObject) -> Result<(),COBIAError>;
}

pub trait ICapeCustomDataSourceImpl : ICapeCustomDataSource {
	type T: ICapeInterfaceImpl+ICapeCustomDataSourceImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeCustomDataSource interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeCustomDataSource_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeCustomDataSourceImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeCustomDataSource =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeCustomDataSource;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeCustomDataSource_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_create_custom_data_container(me: *mut std::ffi::c_void,custom_data_container:*mut *mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if custom_data_container.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if custom_data_container.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		match myself.create_custom_data_container() {
			Ok(_custom_data_container) => {
				unsafe{*custom_data_container=_custom_data_container.detach();}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeCustomDataSource::CreateCustomDataContainer")
		}
	}

	extern "C" fn raw_copy_custom_data(me: *mut std::ffi::c_void,source:*mut crate::C::ICapeInterface,target:*mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if source.is_null()||target.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if source.is_null()||target.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let source=crate::CapeObject::from_interface_pointer(source);
		let target=crate::CapeObject::from_interface_pointer(target);
		match myself.copy_custom_data(source,target) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeCustomDataSource::CopyCustomData")
		}
	}

	extern "C" fn raw_thermodynamic_configuration_changed(me: *mut std::ffi::c_void,container:*mut crate::C::ICapeInterface) -> crate::C::CapeResult {
		if container.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if container.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let container=crate::CapeObject::from_interface_pointer(container);
		match myself.thermodynamic_configuration_changed(container) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeCustomDataSource::ThermodynamicConfigurationChanged")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeCustomDataSource_VTable =
		C::CAPEOPEN_1_2_ICapeCustomDataSource_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			CreateCustomDataContainer: Some(Self::T::raw_create_custom_data_container),
			CopyCustomData: Some(Self::T::raw_copy_custom_data),
			ThermodynamicConfigurationChanged: Some(Self::T::raw_thermodynamic_configuration_changed),
		};
}

#[cape_smart_pointer(ICAPECUSTOMDATASOURCE_UUID)]
pub struct CapeCustomDataSource {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeCustomDataSource,
}

impl CapeCustomDataSource {

	pub fn create_custom_data_container(&self) -> Result<crate::CapeObject,COBIAError> {
		let mut custom_data_container: *mut crate::C::ICapeInterface=std::ptr::null_mut();
		let result_code = unsafe {
			((*(*self.interface).vTbl).CreateCustomDataContainer.unwrap())((*self.interface).me,&mut custom_data_container as *mut *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(crate::CapeObject::attach(custom_data_container))},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn copy_custom_data(&self,source:&crate::CapeObject,target:&crate::CapeObject) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).CopyCustomData.unwrap())((*self.interface).me,source.as_interface_pointer() as *mut crate::C::ICapeInterface,target.as_interface_pointer() as *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn thermodynamic_configuration_changed(&self,container:&crate::CapeObject) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).ThermodynamicConfigurationChanged.unwrap())((*self.interface).me,container.as_interface_pointer() as *mut crate::C::ICapeInterface)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}

///ICapeThermoPetroleumFractions
///
///ICapeThermoPetroleumFractions interface
///
pub trait ICapeThermoPetroleumFractions {
	fn set_petro_compound_prop(&mut self,property_id:&CapeStringIn,basis:&CapeStringIn,values:&CapeArrayRealIn) -> Result<(),COBIAError>;
	fn set_petro_bulk_prop(&mut self,property_id:&CapeStringIn,basis:&CapeStringIn,value:CapeReal) -> Result<(),COBIAError>;
	fn get_petro_compound_prop(&mut self,property_id:&CapeStringIn,basis:&CapeStringIn,values:&mut CapeArrayRealOut) -> Result<(),COBIAError>;
	fn get_petro_bulk_prop(&mut self,property_id:&CapeStringIn,basis:&CapeStringIn) -> Result<CapeReal,COBIAError>;
	fn petro_prop_list(&mut self,property_ids:&mut CapeArrayStringOut) -> Result<(),COBIAError>;
	fn get_petro_prop_attribute(&mut self,property_id:&CapeStringIn,attribute_name:&CapeStringIn,attribute_value:&mut CapeValueOut) -> Result<(),COBIAError>;
	fn copy_petro_properties(&mut self,source:CapeThermoMaterial) -> Result<(),COBIAError>;
	fn update_petro_properties(&mut self) -> Result<(),COBIAError>;
}

pub trait ICapeThermoPetroleumFractionsImpl : ICapeThermoPetroleumFractions {
	type T: ICapeInterfaceImpl+ICapeThermoPetroleumFractionsImpl;

	fn as_interface_pointer(&mut self) -> *mut crate::C::ICapeInterface;

	///prepare CAPEOPEN_1_2_ICapeThermoPetroleumFractions interface and return as generic ICapeInterface pointer
	fn init_interface() -> crate::C::ICapeInterface {
		crate::C::ICapeInterface {
			me: std::ptr::null_mut(),
			vTbl: (&Self::T::VTABLE as *const crate::C::CAPEOPEN_1_2_ICapeThermoPetroleumFractions_VTable).cast_mut()
				as *mut crate::C::ICapeInterface_VTable,
		}
	}
	
	fn init<Timpl: ICapeThermoPetroleumFractionsImpl+ICapeInterfaceImpl>(u: &mut Timpl) {
		let iface: *mut crate::C::CAPEOPEN_1_2_ICapeThermoPetroleumFractions =
			u.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoPetroleumFractions;
		unsafe { (*iface).me = u.get_self() as *const Timpl as *mut std::ffi::c_void };
		u.add_interface(
			std::ptr::addr_of!(C::CAPEOPEN_1_2_ICapeThermoPetroleumFractions_UUID),
			iface as *mut crate::C::ICapeInterface,
		);
	}
	
	extern "C" fn raw_set_petro_compound_prop(me: *mut std::ffi::c_void,property_id:*mut crate::C::ICapeString,basis:*mut crate::C::ICapeString,values:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let property_id=CapeStringIn::new(&property_id);
		let basis=CapeStringIn::new(&basis);
		let values=CapeArrayRealIn::new(&values);
		match myself.set_petro_compound_prop(&property_id,&basis,&values) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPetroleumFractions::SetPetroCompoundProp")
		}
	}

	extern "C" fn raw_set_petro_bulk_prop(me: *mut std::ffi::c_void,property_id:*mut crate::C::ICapeString,basis:*mut crate::C::ICapeString,value:CapeReal) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let property_id=CapeStringIn::new(&property_id);
		let basis=CapeStringIn::new(&basis);
		match myself.set_petro_bulk_prop(&property_id,&basis,value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPetroleumFractions::SetPetroBulkProp")
		}
	}

	extern "C" fn raw_get_petro_compound_prop(me: *mut std::ffi::c_void,property_id:*mut crate::C::ICapeString,basis:*mut crate::C::ICapeString,values:*mut crate::C::ICapeArrayReal) -> crate::C::CapeResult {
		if values.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if values.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let property_id=CapeStringIn::new(&property_id);
		let basis=CapeStringIn::new(&basis);
		let mut values=unsafe{*((&values as *const *mut crate::C::ICapeArrayReal) as *mut *mut crate::C::ICapeArrayReal)};
		let mut values=CapeArrayRealOut::new(&mut values);
		match myself.get_petro_compound_prop(&property_id,&basis,&mut values) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPetroleumFractions::GetPetroCompoundProp")
		}
	}

	extern "C" fn raw_get_petro_bulk_prop(me: *mut std::ffi::c_void,property_id:*mut crate::C::ICapeString,basis:*mut crate::C::ICapeString,value:*mut CapeReal) -> crate::C::CapeResult {
		if value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		let property_id=CapeStringIn::new(&property_id);
		let basis=CapeStringIn::new(&basis);
		match myself.get_petro_bulk_prop(&property_id,&basis) {
			Ok(_value) => {
				unsafe{*value=_value;}
				COBIAERR_NOERROR
			},
			Err(e) => myself.set_last_error(e,"ICapeThermoPetroleumFractions::GetPetroBulkProp")
		}
	}

	extern "C" fn raw_petro_prop_list(me: *mut std::ffi::c_void,property_ids:*mut crate::C::ICapeArrayString) -> crate::C::CapeResult {
		if property_ids.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if property_ids.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let mut property_ids=unsafe{*((&property_ids as *const *mut crate::C::ICapeArrayString) as *mut *mut crate::C::ICapeArrayString)};
		let mut property_ids=CapeArrayStringOut::new(&mut property_ids);
		match myself.petro_prop_list(&mut property_ids) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPetroleumFractions::PetroPropList")
		}
	}

	extern "C" fn raw_get_petro_prop_attribute(me: *mut std::ffi::c_void,property_id:*mut crate::C::ICapeString,attribute_name:*mut crate::C::ICapeString,attribute_value:*mut crate::C::ICapeValue) -> crate::C::CapeResult {
		if attribute_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if attribute_value.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let property_id=CapeStringIn::new(&property_id);
		let attribute_name=CapeStringIn::new(&attribute_name);
		let mut attribute_value=unsafe{*((&attribute_value as *const *mut crate::C::ICapeValue) as *mut *mut crate::C::ICapeValue)};
		let mut attribute_value=CapeValueOut::new(&mut attribute_value);
		match myself.get_petro_prop_attribute(&property_id,&attribute_name,&mut attribute_value) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPetroleumFractions::GetPetroPropAttribute")
		}
	}

	extern "C" fn raw_copy_petro_properties(me: *mut std::ffi::c_void,source:*mut C::CAPEOPEN_1_2_ICapeThermoMaterial) -> crate::C::CapeResult {
		if source.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		if source.is_null() {
			return COBIAERR_NULLPOINTER;
		}
		let source=CapeThermoMaterial::from_interface_pointer(source);
		match myself.copy_petro_properties(source) {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPetroleumFractions::CopyPetroProperties")
		}
	}

	extern "C" fn raw_update_petro_properties(me: *mut std::ffi::c_void) -> crate::C::CapeResult {
		let p = me as *mut Self::T;
		let myself=unsafe { &mut *p };
		match myself.update_petro_properties() {
			Ok(_) => COBIAERR_NOERROR,
			Err(e) => myself.set_last_error(e,"ICapeThermoPetroleumFractions::UpdatePetroProperties")
		}
	}

	const VTABLE: C::CAPEOPEN_1_2_ICapeThermoPetroleumFractions_VTable =
		C::CAPEOPEN_1_2_ICapeThermoPetroleumFractions_VTable {
			base: crate::C::ICapeInterface_VTable {
				addReference: Some(Self::T::raw_add_reference),
				release: Some(Self::T::raw_release),
				queryInterface: Some(Self::T::raw_query_interface),
				getLastError: Some(Self::T::raw_get_last_error),
			},
			SetPetroCompoundProp: Some(Self::T::raw_set_petro_compound_prop),
			SetPetroBulkProp: Some(Self::T::raw_set_petro_bulk_prop),
			GetPetroCompoundProp: Some(Self::T::raw_get_petro_compound_prop),
			GetPetroBulkProp: Some(Self::T::raw_get_petro_bulk_prop),
			PetroPropList: Some(Self::T::raw_petro_prop_list),
			GetPetroPropAttribute: Some(Self::T::raw_get_petro_prop_attribute),
			CopyPetroProperties: Some(Self::T::raw_copy_petro_properties),
			UpdatePetroProperties: Some(Self::T::raw_update_petro_properties),
		};
}

#[cape_smart_pointer(ICAPETHERMOPETROLEUMFRACTIONS_UUID)]
pub struct CapeThermoPetroleumFractions {
	pub(crate) interface: *mut C::CAPEOPEN_1_2_ICapeThermoPetroleumFractions,
}

impl CapeThermoPetroleumFractions {

	pub fn set_petro_compound_prop<TypeOfPropertyId:CapeStringProviderIn,TypeOfBasis:CapeStringProviderIn,TypeOfValues:CapeArrayRealProviderIn>(&self,property_id:&TypeOfPropertyId,basis:&TypeOfBasis,values:&TypeOfValues) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetPetroCompoundProp.unwrap())((*self.interface).me,(&property_id.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&values.as_cape_array_real_in() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn set_petro_bulk_prop<TypeOfPropertyId:CapeStringProviderIn,TypeOfBasis:CapeStringProviderIn>(&self,property_id:&TypeOfPropertyId,basis:&TypeOfBasis,value:CapeReal) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).SetPetroBulkProp.unwrap())((*self.interface).me,(&property_id.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),value)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_petro_compound_prop<TypeOfPropertyId:CapeStringProviderIn,TypeOfBasis:CapeStringProviderIn,TypeOfValues:CapeArrayRealProviderOut>(&self,property_id:&TypeOfPropertyId,basis:&TypeOfBasis,values:&mut TypeOfValues) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetPetroCompoundProp.unwrap())((*self.interface).me,(&property_id.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&values.as_cape_array_real_out() as *const crate::C::ICapeArrayReal).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_petro_bulk_prop<TypeOfPropertyId:CapeStringProviderIn,TypeOfBasis:CapeStringProviderIn>(&self,property_id:&TypeOfPropertyId,basis:&TypeOfBasis) -> Result<CapeReal,COBIAError> {
		let mut value:CapeReal=0.0;
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetPetroBulkProp.unwrap())((*self.interface).me,(&property_id.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&basis.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),&mut value as *mut CapeReal)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(value)},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn petro_prop_list<TypeOfPropertyIds:CapeArrayStringProviderOut>(&self,property_ids:&mut TypeOfPropertyIds) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).PetroPropList.unwrap())((*self.interface).me,(&property_ids.as_cape_array_string_out() as *const crate::C::ICapeArrayString).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn get_petro_prop_attribute<TypeOfPropertyId:CapeStringProviderIn,TypeOfAttributeName:CapeStringProviderIn,TypeOfAttributeValue:CapeValueProviderOut>(&self,property_id:&TypeOfPropertyId,attribute_name:&TypeOfAttributeName,attribute_value:&mut TypeOfAttributeValue) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).GetPetroPropAttribute.unwrap())((*self.interface).me,(&property_id.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&attribute_name.as_cape_string_in() as *const crate::C::ICapeString).cast_mut(),(&attribute_value.as_cape_value_out() as *const crate::C::ICapeValue).cast_mut())
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn copy_petro_properties(&self,source:&CapeThermoMaterial) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).CopyPetroProperties.unwrap())((*self.interface).me,source.as_interface_pointer() as *mut C::CAPEOPEN_1_2_ICapeThermoMaterial)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

	pub fn update_petro_properties(&self) -> Result<(),COBIAError> {
		let result_code = unsafe {
			((*(*self.interface).vTbl).UpdatePetroProperties.unwrap())((*self.interface).me)
		};
		match result_code {
			COBIAERR_NOERROR => {Ok(())},
			_ => Err(COBIAError::from_object(result_code,self))
		}
	}

}


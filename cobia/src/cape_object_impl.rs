use crate::C;
use crate::*;

/// Internal data for CAPE-OPEN object implementations.
///
/// This structure holds the internal data for CAPE-OPEN object implementations,
/// such as the interface pointer, last error information, reference count and
/// the interface map.
///
/// This structure is not typically directly referenced, but rather a reference to it is
/// generated by the `cape_object_implementation` macro.

pub struct CapeObjectData {
	/// Unique pointer to the ICapeInterface implementation.
	interface: C::ICapeInterface,
	/// Last error that occurred in the object.
	last_error: Option<COBIAError>,
	/// Scope of the last error
	last_error_scope: Option<String>,
	/// Reference count for the object.
	ref_count: i32,
	/// Interface map
	interface_map: std::collections::HashMap<CapeUUID, *mut C::ICapeInterface>,
}

/// This trait is implemented by all CAPE-OPEN objects.
///
/// It is not typically needed to implement this trait directly, but rather to use the
/// `cape_object_implementation` macro that generates this trait.

pub trait ICapeInterfaceImpl: std::fmt::Display {
	type T: ICapeInterfaceImpl;

	/// Returns a mutable reference to the internal `CapeObjectData` structure.
	fn get_object_data(&mut self) -> &mut CapeObjectData;
	/// Returns a pointer to the implementing object.
	fn get_self(&mut self) -> *mut Self::T;

	/// the V-table for the ICapeInterface implementation.
	const CAPEINTERFACE_VTABLE: C::ICapeInterface_VTable = C::ICapeInterface_VTable {
		addReference: Some(Self::raw_add_reference),
		release: Some(Self::raw_release),
		queryInterface: Some(Self::raw_query_interface),
		getLastError: Some(Self::raw_get_last_error),
	};

	/// Initializes the object, setting up the interface pointer and adding it to the interface map.
	fn init(&mut self) -> *mut C::ICapeInterface {
		//initialize interface pointer
		self.get_object_data().interface.me =
			self.get_self() as *const Self::T as *mut std::ffi::c_void;
		//add to interface map
		let icapeinterface = self.as_icapeinterface();
		self.add_interface(
			std::ptr::addr_of!(C::ICapeInterface_UUID),
			icapeinterface,
		);
		self.as_icapeinterface()
	}

	/// Utility function for internal object setup
	fn create_object_data<Timpl: ICapeInterfaceImpl>() -> CapeObjectData {
		CapeObjectData {
			interface: C::ICapeInterface {
				me: std::ptr::null_mut(),
				vTbl: (&Timpl::CAPEINTERFACE_VTABLE as *const C::ICapeInterface_VTable).cast_mut(),
			},
			last_error: None,
			last_error_scope: None,
			ref_count: 0,
			interface_map: std::collections::HashMap::new(),
		}
	}

	extern "C" fn raw_add_reference(me: *mut ::std::os::raw::c_void) {
		let p = me as *mut Self::T;
		assert!(unsafe { &mut *p }.get_object_data().ref_count >= 0);
		unsafe { &mut *p }.get_object_data().ref_count += 1;
	}

	extern "C" fn raw_release(me: *mut ::std::os::raw::c_void) {
		let p = me as *mut Self::T;
		let ref_count: &mut i32 = &mut unsafe { (*p).get_object_data() }.ref_count;
		*ref_count -= 1;
		if *ref_count == 0 {
			drop(unsafe { Box::from_raw(me as *mut Self::T) });
		}
	}

	extern "C" fn raw_query_interface(
		me: *mut ::std::os::raw::c_void,
		uuid: *const C::CapeUUID,
		interface: *mut *mut C::ICapeInterface,
	) -> C::CapeResult {
		let p = me as *mut Self::T;
		let object_data: &mut CapeObjectData = unsafe { (*p).get_object_data() };
		match object_data.interface_map.get(&(unsafe { *uuid }).clone()) {
			Some(ptr) => {
				unsafe { *interface = *ptr };
				assert!(object_data.ref_count >= 0);
				object_data.ref_count += 1;
				COBIAERR_NOERROR
			}
			None => COBIAERR_NOSUCHINTERFACE,
		}
	}

	extern "C" fn raw_get_last_error(
		me: *mut ::std::os::raw::c_void,
		error: *mut *mut C::ICapeError,
	) -> C::CapeResult {
		if error == std::ptr::null_mut() {
			return COBIAERR_NULLPOINTER;
		}
		let p = me as *mut Self::T;
		let object_data: &mut CapeObjectData = unsafe { (*p).get_object_data() };
		let e = match &object_data.last_error {
			Some(e) => &e,
			None => &COBIAError::Code(COBIAERR_NOERROR),
		};
		let scope = match &object_data.last_error_scope {
			Some(s) => &s,
			None => "<unknown>",
		};
		unsafe {
			*error = CapeErrorImpl::new(e, scope, &format!("{}",*p)) as *mut C::ICapeError
		};
		COBIAERR_NOERROR
	}

	/// Utility function to add an interface to the interface map.
	///
	/// # Arguments
	/// * `uuid` - A pointer to the UUID of the interface.
	/// * `interface` - A pointer to the ICapeInterface implementation of the interface.

	fn add_interface(&mut self, uuid: *const C::CapeUUID, interface: *mut C::ICapeInterface) {
		self.get_object_data().interface_map.insert((unsafe { *uuid }).clone(),interface);
	}

	/// Utility function to set the last error and scope.
	///
	/// # Arguments
	/// * `error` - The error to set.
	/// * `scope` - The scope of the error, typically a string describing where the error occurred.

	fn set_last_error(&mut self, error: COBIAError, scope: &str) -> C::CapeResult {
		let object_data = self.get_object_data();
		object_data.last_error_scope = Some(scope.to_string());
		let ret_code = match error {
			COBIAError::Code(c) => c,
			_ => COBIAERR_CAPEOPENERROR,
		};
		object_data.last_error = Some(error);
		ret_code
	}

	/// Utility function to clear the last error and scope.

	fn clear_last_error(&mut self) {
		let obj = &mut self.get_object_data();
		obj.last_error_scope = None;
		obj.last_error = None;
	}

	/// Returns a unique pointer to the ICapeInterface implementation of the object.

	fn as_icapeinterface(&mut self) -> *mut C::ICapeInterface {
		&mut self.get_object_data().interface as *mut C::ICapeInterface
	}
}

